<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mod16.calibration API documentation</title>
<meta name="description" content="Calibration of MOD16 against a representative, global eddy covariance (EC)
flux tower network. The model calibration is based on Markov-Chain Monte
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mod16.calibration</code></h1>
</header>
<section id="section-intro">
<p>Calibration of MOD16 against a representative, global eddy covariance (EC)
flux tower network. The model calibration is based on Markov-Chain Monte
Carlo (MCMC). Example use:</p>
<pre><code># For a single run with the configured number of chains
python calibration.py tune --pft=1 --config="my_config.yaml"

# For a 3-folds cross-validation
python calibration.py tune --pft=1 --config="my_config.yaml" --k-folds=3
</code></pre>
<p>The general calibration protocol used here involves:</p>
<ol>
<li>Check how well the chain(s) are mixing by running short, e.g., only 5000
draws from the posterior:
<code>python calibration.py tune 1 --draws=5000</code></li>
<li>If any chain is "sticky," run a short chain while tuning the jump scale:
<code>python calibration.py tune 1 --tune=scaling --draws=5000</code></li>
<li>Using the trace plot from Step (2) as a reference, experiment with
different jump scales to try and achieve the same (optimal) mixing when
tuning on <code>lambda</code> (default) instead, e.g.:
<code>python calibration.py tune 1 --scaling=1e-2 --draws=5000</code></li>
<li>When the right jump scale is found, run a chain at the desired length.</li>
</ol>
<p>Instead of changing <code>draws</code> and <code>scaling</code> at the command line, as above, you
could change these parameters in the configuration file.</p>
<p>Once a good mixture is obtained, it is necessary to prune the samples to
eliminate autocorrelation, e.g., in Python:</p>
<pre><code>python calibration.py plot-autocorr --pft=1 --burn=1000 --thin=10
</code></pre>
<p>A thinned posterior can be exported from the command line, e.g.:</p>
<pre><code>python calibration.py export-posterior ET &lt;parameter_name&gt;
    output.h5 --burn=1000 --thin=10
</code></pre>
<p>NOTE: If using k-folds cross-validation, add the following option to any
command, where K is the number of folds:</p>
<pre><code>--k-folds=K
</code></pre>
<p><strong>The Cal-Val dataset</strong> is a single HDF5 file that contains all the input
variables necessary to drive MOD16 as well as the observed latent heat fluxes
against which the model is calibrated. The HDF5 file specification is as
follows, where the shape of multidimensional arrays is given in terms of
T, the number of time steps (days); N, the number of tower sites; L, the
number of land-cover types (PFTs); and P, a sub-grid of MODIS pixels
surrounding a tower:</p>
<pre><code>FLUXNET/
  SEB               -- (T x N) Surface energy balance, from tower data
  air_temperature   -- (T x N) Air temperatures reported at the tower
  *latent_heat      -- (T x N) Observed latent heat flux [W m-2]
  site_id           -- (N) Unique identifier for each site, e.g., "US-BZS"
</code></pre>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
validation_mask
&ndash; (T x N) Indicates what site-days are reserved</p>
<pre><code>MERRA2/
</code></pre>
<p>=======
validation_mask
&ndash; (L x T x N) Indicates what site-days are reserved</p>
<pre><code>*MERRA2/
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>master
LWGNT
&ndash; (T x N) Net long-wave radiation, 24-hr mean [W m-2]
LWGNT_daytime
&ndash; (T x N) &hellip; for daytime hours only
LWGNT_nighttime
&ndash; (T x N) &hellip; for nighttime hours only
PS
&ndash; (T x N) Surface air pressure [Pa]
PS_daytime
&ndash; (T x N) &hellip; for daytime hours only
PS_nighttime
&ndash; (T x N) &hellip; for nighttime hours only
QV10M
&ndash; (T x N) Water vapor mixing ratio at 10-meter height
QV10M_daytime
&ndash; (T x N) &hellip; for daytime hours only
QV10M_nighttime
&ndash; (T x N) &hellip; for nighttime hours only
SWGDN
&ndash; (T x N) Down-welling short-wave radiation [W m-2]
SWGDN_daytime
&ndash; (T x N) &hellip; for daytime hours only
SWGDN_nighttime
&ndash; (T x N) &hellip; for nighttime hours only
T10M
&ndash; (T x N) Air temperature at 10-meter height [deg C]
T10M_daytime
&ndash; (T x N) &hellip; for daytime hours only
T10M_nighttime
&ndash; (T x N) &hellip; for nighttime hours only
Tmin
&ndash; (T x N) Daily minimum air temperature [deg C]</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
MODIS/
MCD43GF_black_sky_sw_albedo
&ndash; (T x N x P) Short-wave albedo under black-sky conditions
MOD15A2HGF_LAI
&ndash; (T x N x P) Leaf area index in scaled units (10 * [m3 m-3])
MOD15A2HGF_LAI_interp
&ndash; (T x N x P) Daily interpolation of the MOD15A2HGF_LAI field
MOD15A2HGF_fPAR
&ndash; (T x N x P) Fraction of photosynthetically active radiation [%]
MOD15A2HGF_fPAR_interp
&ndash; (T x N x P) Daily interpolation of MOD15A2HGF_fPAR_interp field
=======
<em>MODIS/
</em>MCD43GF_black_sky_sw_albedo
&ndash; (T x N x P) Short-wave albedo under black-sky conditions
<em>MOD15A2HGF_LAI
&ndash; (T x N x P) Leaf area index in scaled units (10 * [m3 m-3])
</em>MOD15A2HGF_fPAR
&ndash; (T x N x P) Fraction of photosynthetically active radiation [%]</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>master</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>*IMERG/
  *mean_annual_precip
      -- (Y x N) Mean annual precipitation in each year (Y years)

coordinates/
  lng_lat       -- (2 x N) Longitude, latitude coordinates of each tower

state/
  *PFT          -- (N x P) The plant functional type (PFT) of each pixel
  elevation_m   -- (N) The elevation in meters above sea level

time            -- (T x 3) The Year, Month, Day of each daily time step
weights         -- (N) A number between 0 and 1 used to down-weight towers
</code></pre>
<h1 id="head">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1>
<p>NOTE: A star, <code>*</code>, indicates that this dataset or group's name can be changed
in the configuration file. All others are currently required to match this
specification exactly.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>master</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Calibration of MOD16 against a representative, global eddy covariance (EC)
flux tower network. The model calibration is based on Markov-Chain Monte
Carlo (MCMC). Example use:

    # For a single run with the configured number of chains
    python calibration.py tune --pft=1 --config=&#34;my_config.yaml&#34;

    # For a 3-folds cross-validation
    python calibration.py tune --pft=1 --config=&#34;my_config.yaml&#34; --k-folds=3

The general calibration protocol used here involves:

1. Check how well the chain(s) are mixing by running short, e.g., only 5000
draws from the posterior:
`python calibration.py tune 1 --draws=5000`
2. If any chain is &#34;sticky,&#34; run a short chain while tuning the jump scale:
`python calibration.py tune 1 --tune=scaling --draws=5000`
3. Using the trace plot from Step (2) as a reference, experiment with
different jump scales to try and achieve the same (optimal) mixing when
tuning on `lambda` (default) instead, e.g.:
`python calibration.py tune 1 --scaling=1e-2 --draws=5000`
4. When the right jump scale is found, run a chain at the desired length.

Instead of changing `draws` and `scaling` at the command line, as above, you
could change these parameters in the configuration file.

Once a good mixture is obtained, it is necessary to prune the samples to
eliminate autocorrelation, e.g., in Python:

    python calibration.py plot-autocorr --pft=1 --burn=1000 --thin=10

A thinned posterior can be exported from the command line, e.g.:

    python calibration.py export-posterior ET &lt;parameter_name&gt;
        output.h5 --burn=1000 --thin=10

NOTE: If using k-folds cross-validation, add the following option to any
command, where K is the number of folds:

    --k-folds=K

**The Cal-Val dataset** is a single HDF5 file that contains all the input
variables necessary to drive MOD16 as well as the observed latent heat fluxes
against which the model is calibrated. The HDF5 file specification is as
follows, where the shape of multidimensional arrays is given in terms of
T, the number of time steps (days); N, the number of tower sites; L, the
number of land-cover types (PFTs); and P, a sub-grid of MODIS pixels
surrounding a tower:


    FLUXNET/
      SEB               -- (T x N) Surface energy balance, from tower data
      air_temperature   -- (T x N) Air temperatures reported at the tower
      *latent_heat      -- (T x N) Observed latent heat flux [W m-2]
      site_id           -- (N) Unique identifier for each site, e.g., &#34;US-BZS&#34;
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
      validation_mask   -- (T x N) Indicates what site-days are reserved

    MERRA2/
=======
      validation_mask   -- (L x T x N) Indicates what site-days are reserved

    *MERRA2/
&gt;&gt;&gt;&gt;&gt;&gt;&gt; master
      LWGNT             -- (T x N) Net long-wave radiation, 24-hr mean [W m-2]
      LWGNT_daytime     -- (T x N) ... for daytime hours only
      LWGNT_nighttime   -- (T x N) ... for nighttime hours only
      PS                -- (T x N) Surface air pressure [Pa]
      PS_daytime        -- (T x N) ... for daytime hours only
      PS_nighttime      -- (T x N) ... for nighttime hours only
      QV10M             -- (T x N) Water vapor mixing ratio at 10-meter height
      QV10M_daytime     -- (T x N) ... for daytime hours only
      QV10M_nighttime   -- (T x N) ... for nighttime hours only
      SWGDN             -- (T x N) Down-welling short-wave radiation [W m-2]
      SWGDN_daytime     -- (T x N) ... for daytime hours only
      SWGDN_nighttime   -- (T x N) ... for nighttime hours only
      T10M              -- (T x N) Air temperature at 10-meter height [deg C]
      T10M_daytime      -- (T x N) ... for daytime hours only
      T10M_nighttime    -- (T x N) ... for nighttime hours only
      Tmin              -- (T x N) Daily minimum air temperature [deg C]

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
    MODIS/
      MCD43GF_black_sky_sw_albedo
          -- (T x N x P) Short-wave albedo under black-sky conditions
      MOD15A2HGF_LAI
          -- (T x N x P) Leaf area index in scaled units (10 * [m3 m-3])
      MOD15A2HGF_LAI_interp
          -- (T x N x P) Daily interpolation of the MOD15A2HGF_LAI field
      MOD15A2HGF_fPAR
          -- (T x N x P) Fraction of photosynthetically active radiation [%]
      MOD15A2HGF_fPAR_interp
          -- (T x N x P) Daily interpolation of MOD15A2HGF_fPAR_interp field
=======
    *MODIS/
      *MCD43GF_black_sky_sw_albedo
          -- (T x N x P) Short-wave albedo under black-sky conditions
      *MOD15A2HGF_LAI
          -- (T x N x P) Leaf area index in scaled units (10 * [m3 m-3])
      *MOD15A2HGF_fPAR
          -- (T x N x P) Fraction of photosynthetically active radiation [%]
&gt;&gt;&gt;&gt;&gt;&gt;&gt; master

    *IMERG/
      *mean_annual_precip
          -- (Y x N) Mean annual precipitation in each year (Y years)

    coordinates/
      lng_lat       -- (2 x N) Longitude, latitude coordinates of each tower

    state/
      *PFT          -- (N x P) The plant functional type (PFT) of each pixel
      elevation_m   -- (N) The elevation in meters above sea level

    time            -- (T x 3) The Year, Month, Day of each daily time step
    weights         -- (N) A number between 0 and 1 used to down-weight towers
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
=======


NOTE: A star, `*`, indicates that this dataset or group&#39;s name can be changed
in the configuration file. All others are currently required to match this
specification exactly.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; master
&#39;&#39;&#39;

import datetime
import yaml
import os
import numpy as np
import h5py
import pymc as pm
import pytensor.tensor as pt
import arviz as az
import mod16
from functools import partial
from statistics import mode
from pathlib import Path
from typing import Sequence
from scipy import signal
from matplotlib import pyplot
from mod16 import MOD16, latent_heat_vaporization
from mod16.utils import restore_bplut, pft_dominant
from mod17.calibration import BlackBoxLikelihood, StochasticSampler

MOD16_DIR = os.path.dirname(mod16.__file__)


class MOD16StochasticSampler(StochasticSampler):
    &#39;&#39;&#39;
    A Markov Chain-Monte Carlo (MCMC) sampler for MOD16. The specific sampler
    used is the Differential Evolution (DE) MCMC algorithm described by
    Ter Braak (2008), though the implementation is specific to the PyMC3
    library.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    model : Callable
        The function to call (with driver data and parameters); this function
        should take driver data as positional arguments and the model
        parameters as a `*Sequence`; it should require no external state.
    observed : Sequence
        Sequence of observed values that will be used to calibrate the model;
        i.e., model is scored by how close its predicted values are to the
        observed values
    params_dict : dict or None
        Dictionary of model parameters, to be used as initial values and as
        the basis for constructing a new dictionary of optimized parameters
    backend : str or None
        Path to a NetCDF4 file backend (Default: None)
    weights : Sequence or None
        Optional sequence of weights applied to the model residuals (as in
        weighted least squares)
    &#39;&#39;&#39;
    required_parameters = {
        &#39;ET&#39;: MOD16.required_parameters
    }
    required_drivers = {
        &#39;ET&#39;: [
            &#39;lw_net_day&#39;, &#39;lw_net_night&#39;, &#39;sw_rad_day&#39;, &#39;sw_rad_night&#39;,
            &#39;sw_albedo&#39;, &#39;temp_day&#39;, &#39;temp_night&#39;, &#39;temp_annual&#39;, &#39;tmin&#39;,
            &#39;vpd_day&#39;, &#39;vpd_night&#39;, &#39;pressure&#39;, &#39;fpar&#39;, &#39;lai&#39;
        ]
    }

    def compile_et_model(
            self, observed: Sequence, drivers: Sequence) -&gt; pm.Model:
        &#39;&#39;&#39;
        Creates a new ET model based on the prior distribution. Model can be
        re-compiled multiple times, e.g., for cross validation.

        There are two attributes that are set on the sampler when it is
        initialized that could be helpful here:

            self.priors
            self.bounds

        `self.priors` is a dict with a key for each parameter that has
        informative priors. For parameters with a non-informative (Uniform)
        prior, `self.bounds` is a similar dict (with a key for each parameter)
        that describes the lower and upper bounds of the Uniform prior, but
        this is deprecated.

        Parameters
        ----------
        observed : Sequence
            Sequence of observed values that will be used to calibrate the model;
            i.e., model is scored by how close its predicted values are to the
            observed values
        drivers : list or tuple
            Sequence of driver datasets to be supplied, in order, to the
            model&#39;s run function

        Returns
        -------
        pm.Model
        &#39;&#39;&#39;
        # Define the objective/ likelihood function
        log_likelihood = BlackBoxLikelihood(
            self.model, observed, x = drivers, weights = self.weights,
            objective = self.config[&#39;optimization&#39;][&#39;objective&#39;],
            constraints = self.constraints)
        # With this context manager, &#34;all PyMC3 objects introduced in the indented
        #   code block...are added to the model behind the scenes.&#34;
        with pm.Model() as model:
            # NOTE: Parameters shared with MOD17 are fixed based on MOD17
            #   re-calibration
            tmin_close = self.params[&#39;tmin_close&#39;]
            tmin_open = self.params[&#39;tmin_open&#39;]
            vpd_open = self.params[&#39;vpd_open&#39;]
            vpd_close = self.params[&#39;vpd_close&#39;]
            gl_sh =       pm.LogNormal(&#39;gl_sh&#39;, **self.prior[&#39;gl_sh&#39;])
            gl_wv =       pm.LogNormal(&#39;gl_wv&#39;, **self.prior[&#39;gl_wv&#39;])
            g_cuticular = pm.LogNormal(
                &#39;g_cuticular&#39;, **self.prior[&#39;g_cuticular&#39;])
            csl =         pm.LogNormal(&#39;csl&#39;, **self.prior[&#39;csl&#39;])
            rbl_min =     pm.Uniform(&#39;rbl_min&#39;, **self.prior[&#39;rbl_min&#39;])
            rbl_max =     pm.Uniform(&#39;rbl_max&#39;, **self.prior[&#39;rbl_max&#39;])
            beta =        pm.Uniform(&#39;beta&#39;, **self.prior[&#39;beta&#39;])
            # (Stochstic) Priors for unknown model parameters
            params_list = [
                tmin_close, tmin_open, vpd_open, vpd_close, gl_sh, gl_wv,
                g_cuticular, csl, rbl_min, rbl_max, beta
            ]
            # Convert model parameters to a tensor vector
            params = pt.as_tensor_variable(params_list)
            # Key step: Define the log-likelihood as an added potential
            pm.Potential(&#39;likelihood&#39;, log_likelihood(params))
        # If the value for this parameter (and this PFT) is fixed...
        fixed = dict()
        for i, name in enumerate(self.required_parameters[&#39;ET&#39;]):
            if self.fixed is not None:
                if name in self.fixed.keys():
                    if self.fixed[name] is not None:
                        # e.g., {beta: fixed_value}
                        fixed[getattr(model, name)] = self.fixed[name]
        if len(fixed) &gt; 0:
            # i.e., Return &#34;a distinct PyMC model with the relevant variables
            #   replaced by the intervention expressions; all remaining
            #   variables are cloned&#34;
            return pm.do(model, fixed)
        return model


class CalibrationAPI(object):
    &#39;&#39;&#39;
    Convenience class for calibrating the MOD16 ET model. Meant to be used
    at the command line, in combination with the option to specify a
    configuration file:

        --config=my_configuration.yaml

    For example, to run calibration for PFT 1, you would write:

        python calibration.py tune --pft=1 --config=my_configuration.yaml

    If `--config` is not provided, the default configuration file,
    `mod16/MOD16_calibration_config.yaml` will be used.
    &#39;&#39;&#39;

    def __init__(self, config = None):
        config_file = config
        if config_file is None:
            config_file = os.path.join(
                MOD16_DIR, &#39;data/MOD16_calibration_config.yaml&#39;)
        print(f&#39;Using configuration file: &#34;{config_file}&#34;&#39;)
        with open(config_file, &#39;r&#39;) as file:
            self.config = yaml.safe_load(file)
        self.hdf5 = self.config[&#39;data&#39;][&#39;file&#39;]

    def _filter(self, raw: Sequence, size: int):
        &#39;Apply a smoothing filter with zero phase offset&#39;
        if size &gt; 1:
            window = np.ones(size) / size
            return np.apply_along_axis(
                lambda x: signal.filtfilt(window, np.ones(1), x), 0, raw)
        return raw # Or, revert to the raw data

    def _load_data(self, pft: int):
        &#39;Read in driver datasets from the HDF5 file&#39;
        with h5py.File(self.hdf5, &#39;r&#39;) as hdf:
            sites = hdf[&#39;FLUXNET/site_id&#39;][:].tolist()
            if hasattr(sites[0], &#39;decode&#39;):
                sites = [s.decode(&#39;utf-8&#39;) for s in sites]
            # Number of time steps
            nsteps = hdf[&#39;time&#39;].shape[0]
            # In case some tower sites should not be used
            blacklist = self.config[&#39;data&#39;][&#39;sites_blacklisted&#39;]
            # Get dominant PFT across a potentially heterogenous sub-grid,
            #   centered on the eddy covariance flux tower, UNLESS we have a
            #   dynamic land-cover map, in which case it is assumed
            #   (required) that there is only one PFT value per site
            pft_array = hdf[self.config[&#39;data&#39;][&#39;class_map&#39;]][:]
            if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
                pft_map = pft_array.copy()
                # Also, ensure the blacklist matches the shape of this mask;
                #   i.e., blacklisted sites should NEVER be used
                if blacklist is not None:
                    if len(blacklist) &gt; 0:
                        blacklist = np.array(blacklist)
                        blacklist = blacklist[None,:].repeat(pft_map.shape[0], axis = 0)
            else:
                # For a static PFT map, sub-site land-cover heterogeneity is
                #   allowed; get the dominant (single) PFT at each site
                pft_map = pft_dominant(pft_array, site_list = sites)
                # But do create a (T x N) selection mask
                pft_map = pft_map[np.newaxis,:].repeat(nsteps, axis = 0)

            # Get a binary mask that indicates which tower-days should be used
            #   to calibrate the current PFT class
            if blacklist is not None:
                pft_mask = np.logical_and(
                    pft_map == pft, ~np.in1d(sites, blacklist))
            else:
                pft_mask = pft_map == pft
            if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
                assert pft_mask.ndim == 2 and pft_mask.shape[0] == nsteps,\
                    &#39;Configuration setting &#34;classes_are_dynamic&#34; implies the &#34;class_map&#34; should be (T x N) but it is not&#39;

            # Get tower weights, for when towers are too close together
            weights = hdf[&#39;weights&#39;][:]
            # If only a single value is given for each site, repeat the weight
            #   along the time axis
            if weights.ndim == 1:
                weights = weights[None,:].repeat(nsteps, axis = 0)[pft_mask]

            # Read in tower observations
            tower_obs = hdf[&#39;FLUXNET/latent_heat&#39;][:][pft_mask]
            # Read the validation mask; mask out observations that are
            #   reserved for validation
            print(&#39;Masking out validation data...&#39;)
            mask = hdf[&#39;FLUXNET/validation_mask&#39;][pft]
            tower_obs[mask] = np.nan

            # Read in driver datasets0
            print(&#39;Loading driver datasets...&#39;)
            group = self.config[&#39;data&#39;][&#39;met_group&#39;]
            lw_net_day = hdf[f&#39;{group}/LWGNT_daytime&#39;][:][pft_mask]
            lw_net_night = hdf[f&#39;{group}/LWGNT_nighttime&#39;][:][pft_mask]
            sw_albedo = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;albedo&#39;]][:][pft_mask]
            sw_rad_day = hdf[f&#39;{group}/SWGDN_daytime&#39;][:][pft_mask]
            sw_rad_night = hdf[f&#39;{group}/SWGDN_nighttime&#39;][:][pft_mask]
            temp_day = hdf[f&#39;{group}/T10M_daytime&#39;][:][pft_mask]
            temp_night = hdf[f&#39;{group}/T10M_nighttime&#39;][:][pft_mask]
            tmin = hdf[f&#39;{group}/Tmin&#39;][:][pft_mask]

            # As long as the time series is balanced w.r.t. years (i.e., same
            #   number of records per year), the overall mean is the annual mean
            temp_annual = hdf[f&#39;{group}/T10M&#39;][:][pft_mask].mean(axis = 0)
            vpd_day = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_daytime&#39;][:][pft_mask],
                hdf[f&#39;{group}/PS_daytime&#39;][:][pft_mask],
                temp_day)
            vpd_night = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_nighttime&#39;][:][pft_mask],
                hdf[f&#39;{group}/PS_nighttime&#39;][:][pft_mask],
                temp_night)

            # After VPD is calculated, air pressure is based solely
            #   on elevation
            elevation = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;elevation&#39;]][:]
            elevation = elevation[np.newaxis,:]\
                .repeat(nsteps, axis = 0)[pft_mask]
            pressure = MOD16.air_pressure(elevation.mean(axis = -1))

            # Read in fPAR, LAI, and convert from (%) to [0,1]
            fpar = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;fPAR&#39;]][:][pft_mask]
            lai = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;LAI&#39;]][:][pft_mask]

            # If a heterogeneous sub-grid is used at each tower (i.e., there
            #   is a third axis to these datasets), then average over that
            #   sub-grid
            if sw_albedo.ndim == 2 and fpar.ndim == 2 and lai.ndim == 2:
                sw_albedo = np.nanmean(sw_albedo, axis = -1)
                fpar = np.nanmean(fpar, axis = -1)
                lai = np.nanmean(lai, axis = -1)
            # Convert fPAR from (%) to [0,1] and re-scale LAI; reshape fPAR and LAI
            fpar /= 100
            lai /= 10

        # Compile driver datasets
        drivers = [
            lw_net_day, lw_net_night, sw_rad_day, sw_rad_night, sw_albedo,
            temp_day, temp_night, temp_annual, tmin, vpd_day, vpd_night,
            pressure, fpar, lai
        ]
        return (tower_obs, drivers, weights)

    def _load_data_annual(self, pft: int):
        &#39;Read in driver datasets from the HDF5 file, structured by years&#39;
        constraints = dict()
        with h5py.File(self.hdf5, &#39;r&#39;) as hdf:
            sites = hdf[&#39;FLUXNET/site_id&#39;][:].tolist()
            if hasattr(sites[0], &#39;decode&#39;):
                sites = [s.decode(&#39;utf-8&#39;) for s in sites]
            # Number of time steps
            nsteps = hdf[&#39;time&#39;].shape[0]
            # In case some tower sites should not be used
            blacklist = self.config[&#39;data&#39;][&#39;sites_blacklisted&#39;]
            # Get dominant PFT across a potentially heterogenous sub-grid,
            #   centered on the eddy covariance flux tower
            pft_map = hdf[self.config[&#39;data&#39;][&#39;class_map&#39;]][:]
            # Also, ensure the blacklist matches the shape of this mask;
            #   i.e., blacklisted sites should NEVER be used
            if blacklist is not None:
                if len(blacklist) &gt; 0:
                    blacklist = np.array(blacklist)
                    blacklist = blacklist[None,:].repeat(pft_map.shape[0], axis = 0)

            years = np.array([
                datetime.date(*ymd).year for ymd in hdf[&#39;time&#39;][:].tolist()
            ])
            # If any days of this year correspond to the current PFT, select
            #   that year for calibration
            year_masks = []
            valid = self.config[&#39;data&#39;][&#39;classes&#39;] # Valid PFT classes
            for y in np.unique(years):
                # NOTE: This is where we select the current year
                pft_map_now = pft_map[years == y].swapaxes(0,1)
                pft_map_now = pft_map_now.reshape(
                    (pft_map_now.shape[0], pft_map_now.size // pft_map_now.shape[0]))
                # Update the PFT map (this year) to handle invalid PFT classes
                for i in range(pft_map_now.shape[0]):
                    if not np.in1d(pft_map_now[i], valid).all():
                        # Replace invalid PFTs (this year) with most common
                        #   valid PFT
                        potential = pft_map_now[i,np.in1d(pft_map_now[i], valid)]
                        if potential.size == 0:
                            continue # Skip this for now
                        pft_map_now[i,~np.in1d(pft_map_now[i], valid)] =\
                            mode(potential)
                # Now, with (mostly) good PFTs (this year), find the dominant
                pft_map_now = np.apply_along_axis(mode, 1, pft_map_now)
                year_masks.append(pft_map_now == pft)

            year_masks = np.stack(year_masks, axis = 0)
            # &#34;Average&#34; over the subgrid, then select years where a site has
            #   that PFT for any part of the year; to verify that this has
            #   resulted in an array that indicates which (full) years a PFT
            #   occurs at each site, try:
            # np.apply_along_axis(lambda x: x.sum(), 0, year_masks)
            pft_mask = year_masks[years - years.min()]
            # Set as False any tower-days where the tower is blacklisted
            if blacklist is not None:
                pft_mask[:,np.in1d(sites, blacklist)] = False
            # Finally, get an (N,) selection mask for the towers we want
            site_mask = pft_mask.any(axis = 0)

            # Get tower weights, for when towers are too close together
            weights = hdf[&#39;weights&#39;][:]
            # If only a single value is given for each site, repeat the weight
            #   along the time axis
            if weights.ndim == 1:
                weights = weights[None,...].repeat(nsteps, axis = 0)
            weights = weights[:,site_mask]

            # Read in tower observations; we select obs of interest in three
            #   steps because we want *only* matching tower-day observations
            #   but we&#39;ll want driver data for a full year if that year
            #   contains *any* matching tower-day observations
            print(&#39;Masking out validation data...&#39;)
            tower_obs = hdf[&#39;FLUXNET/latent_heat&#39;][:]
            tower_obs[~pft_mask] = np.nan # Step 1: Mask out invalid days
            # Step 2: Mask out validation samples
            tower_obs[hdf[&#39;FLUXNET/validation_mask&#39;][pft]] = np.nan
            tower_obs = tower_obs[:,site_mask] # Step 3: Select matching sites

            # Read in driver datasets0
            print(&#39;Loading driver datasets...&#39;)
            group = self.config[&#39;data&#39;][&#39;met_group&#39;]
            lw_net_day = hdf[f&#39;{group}/LWGNT_daytime&#39;][:][:,site_mask]
            lw_net_night = hdf[f&#39;{group}/LWGNT_nighttime&#39;][:][:,site_mask]
            sw_albedo = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;albedo&#39;]][:][:,site_mask]
            sw_rad_day = hdf[f&#39;{group}/SWGDN_daytime&#39;][:][:,site_mask]
            sw_rad_night = hdf[f&#39;{group}/SWGDN_nighttime&#39;][:][:,site_mask]
            temp_day = hdf[f&#39;{group}/T10M_daytime&#39;][:][:,site_mask]
            temp_night = hdf[f&#39;{group}/T10M_nighttime&#39;][:][:,site_mask]
            tmin = hdf[f&#39;{group}/Tmin&#39;][:][:,site_mask]

            if self.config[&#39;constraints&#39;][&#39;annual_precipitation&#39;]:
                # Convert mean annual precip (Y x N) to a (T x N) array,
                #   then subset
                ann_precip = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;annual_precip&#39;]][:]
                constraints[&#39;annual_precipitation&#39;] = (years, ann_precip[:,site_mask])

            # As long as the time series is balanced w.r.t. years (i.e., same
            #   number of records per year), the overall mean is the annual mean
            temp_annual = hdf[f&#39;{group}/T10M&#39;][:][:,site_mask].mean(axis = 0)
            vpd_day = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_daytime&#39;][:][:,site_mask],
                hdf[f&#39;{group}/PS_daytime&#39;][:][:,site_mask],
                temp_day)
            vpd_day = np.where(vpd_day &lt; 0, 0, vpd_day)
            vpd_night = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_nighttime&#39;][:][:,site_mask],
                hdf[f&#39;{group}/PS_nighttime&#39;][:][:,site_mask],
                temp_night)
            vpd_night = np.where(vpd_night &lt; 0, 0, vpd_night)

            # After VPD is calculated, air pressure is based solely
            #   on elevation
            elevation = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;elevation&#39;]][:]
            elevation = elevation[np.newaxis,:]\
                .repeat(nsteps, axis = 0)[:,site_mask]
            pressure = MOD16.air_pressure(elevation.mean(axis = -1))

            # Read in fPAR, LAI, and convert from (%) to [0,1]
            fpar = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;fPAR&#39;]][:][:,site_mask]
            lai = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;LAI&#39;]][:][:,site_mask]

            # If a heterogeneous sub-grid is used at each tower (i.e., there
            #   is a third axis to these datasets), then average over that
            #   sub-grid
            if sw_albedo.ndim == 3 and fpar.ndim == 3 and lai.ndim == 3:
                sw_albedo = np.nanmean(sw_albedo, axis = -1)
                fpar = np.nanmean(fpar, axis = -1)
                lai = np.nanmean(lai, axis = -1)
            # Convert fPAR from (%) to [0,1] and re-scale LAI; reshape fPAR and LAI
            fpar /= 100
            lai /= 10

        drivers = [
            lw_net_day, lw_net_night, sw_rad_day, sw_rad_night, sw_albedo,
            temp_day, temp_night, temp_annual, tmin, vpd_day, vpd_night,
            pressure, fpar, lai
        ]
        return (tower_obs, drivers, weights, constraints)

    def clean_observed(
            self, raw: Sequence, drivers: Sequence, protocol: str = &#39;ET&#39;,
            filter_length: int = 2) -&gt; Sequence:
        &#39;&#39;&#39;
        Cleans observed tower flux data according to a prescribed protocol.
        NOT intended to be called from the command line.

        Parameters
        ----------
        raw : Sequence
        drivers : Sequence
        protocol : str
        filter_length : int
            The window size for the smoothing filter, applied to the observed
            data

        Returns
        -------
        Sequence
        &#39;&#39;&#39;
        # Read in the observed data and apply smoothing filter; then mask out
        #   negative latent heat observations
        obs = self._filter(raw, filter_length)
        return np.where(obs &lt; 0, np.nan, obs)

    def export_posterior(
            self, model: str, param: str, output_path: str, thin: int = 10,
            burn: int = 1000, k_folds: int = 1):
        &#39;&#39;&#39;
        Exports posterior distribution for a parameter, for each PFT to HDF5.

        Parameters
        ----------
        model : str
            The name of the model (only &#34;ET&#34; is supported)
        param : str
            The model parameter to export
        output_path : str
            The output HDF5 file path
        thin : int
            Thinning rate
        burn : int
            The burn-in (i.e., first N samples to discard)
        k_folds : int
            The number of k-folds used in cross-calibration/validation;
            if more than one (default), the folds for each PFT will be
            combined into a single HDF5 file
        &#39;&#39;&#39;
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][model])
        bplut = params_dict.copy()
        # Filter the parameters to just those for the PFT of interest
        post = []
        for pft in self.config[&#39;data&#39;][&#39;classes&#39;]:
            params = dict([(k, v[pft]) for k, v in params_dict.items()])
            post_by_fold = []
            for fold in range(1, k_folds + 1):
                backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] %\
                    (model, pft)
                if k_folds &gt; 1:
                    backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]
                # NOTE: This value was hard-coded in the extant version of MOD16
                if &#39;beta&#39; not in params:
                    params[&#39;beta&#39;] = 250
                sampler = MOD16StochasticSampler(
                    self.config, getattr(MOD16, &#39;_%s&#39; % model.lower()), params,
                    backend = backend)
                trace = sampler.get_trace()
                fit = trace.sel(draw = slice(burn, None, thin))[&#39;posterior&#39;]
                if param in fit:
                    post_by_fold.append(
                        az.extract_dataset(fit, combined = True)[param].values)
                else:
                    # In case there is, e.g., a parameter that takes on a
                    #   constant value for a specific PFT
                    if k_folds &gt; 1:
                        post_by_fold.append(
                            np.ones((1, post[-1].shape[-1])) * np.nan)
                    else:
                        a_key = list(fit.keys())[0]
                        post_by_fold.append(
                            np.ones(fit[a_key].values.shape) * np.nan)
            if k_folds &gt; 1:
                post.append(np.vstack(post_by_fold))
            else:
                post.extend(post_by_fold)
        # If not every PFT&#39;s posterior has the same number of samples (e.g.,
        #   when one set of chains was run longer than another)...
        if not all([p.shape == post[0].shape for p in post]):
            max_len = max([p.shape for p in post])[0]
            # ...Reshape all posteriors to match the greatest sample size
            post = [
                np.pad(
                    p.astype(np.float32), (0, max_len - p.size),
                    mode = &#39;constant&#39;, constant_values = (np.nan,))
                for p in post
            ]
        with h5py.File(output_path, &#39;a&#39;) as hdf:
            post = np.stack(post)
            ts = datetime.date.today().strftime(&#39;%Y-%m-%d&#39;) # Today&#39;s date
            dataset = hdf.create_dataset(
                f&#39;{param}_posterior&#39;, post.shape, np.float32, post)
            dataset.attrs[&#39;description&#39;] = &#39;CalibrationAPI.export_posterior() on {ts}&#39;

    def plot_autocorr(self, pft: int, k_folds: int = 1, **kwargs):
        &#39;&#39;&#39;
        Plot the autocorrelation in the trace for each parameter.

        Parameters
        ----------
        pft : int
            The numeric PFT code
        &#39;&#39;&#39;
        # Filter the parameters to just those for the PFT of interest
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
        params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
        backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
        # Use a different naming scheme for the backend
        if k_folds &gt; 1:
            for fold in range(1, k_folds + 1):
                sampler = MOD16StochasticSampler(
                    self.config, MOD16._et, params_dict,
                    backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):])
                sampler.plot_autocorr(**kwargs, title = f&#39;Fold {fold} of {k_folds}&#39;)
        else:
            sampler = MOD16StochasticSampler(
                self.config, MOD16._et, params_dict, backend = backend)
            sampler.plot_autocorr(**kwargs)

    def tune(
            self, pft: int, plot_trace: bool = False, k_folds: int = 1,
            ipdb: bool = False, save_fig: bool = False, **kwargs):
        &#39;&#39;&#39;
        Run the MOD16 ET calibration. If k-folds cross-validation is used,
        the model is calibrated on $k$ random subsets of the data and a
        series of file is created, e.g., as:

            MOD16_ET_calibration_PFT1.h5
            MOD16_ET_calibration_PFT1-k1.nc4
            MOD16_ET_calibration_PFT1-k2.nc4
            ...

        Where each `.nc4` file is a standard `arviz` backend and the `.h5`
        indicates which indices from the observations vector, after removing
        NaNs, were excluded (i.e., the indices of the test data).

        Parameters
        ----------
        pft : int
            The Plant Functional Type (PFT) to calibrate
        plot_trace : bool
            True to plot the trace for a previous calibration run; this will
            also NOT start a new calibration (Default: False)
        k_folds : int
            Number of folds to use in k-folds cross-validation; defaults to
            k=1, i.e., no cross-validation is performed.
        ipdb : bool
            True to drop the user into an ipdb prompt, prior to and instead of
            running calibration
        save_fig : bool
            True to save figures to files instead of showing them
            (Default: False)
        **kwargs
            Additional keyword arguments passed to
            `MOD16StochasticSampler.run()`

        NOTE that `MOD16StochasticSampler` inherits methods from the `mod17`
        module, including [run()](https://arthur-e.github.io/MOD17/calibration.html#mod17.calibration.StochasticSampler).
        &#39;&#39;&#39;
        def constrain_by_map(pred_le, years, lhv, annual_precip):
            # Constraint the results by (mean) annual precipitation
            # pred_le : np.ndarray - (T,N) array of predicted latent heat flux
            # years : np.ndarray - (T,) array indicating year, out of Y years
            # lhv : np.ndarray - (T,N) array of latent heat of vaporization
            # annual_precip : np.ndarray -
            #   (Y,N) array of the annual precipitation at the site
            mass_rate = (pred_le * 60 * 60 * 24) / lhv # Convert [W m-2] to [mm day-1]
            mass_rate[mass_rate &lt; 0] = 0
            annual_mass_rate = []
            for y in np.unique(years):
                a = np.apply_along_axis(
                    lambda x: x.sum(), 0, mass_rate[years == y])
                annual_mass_rate.append(a)
            pred_precip = np.stack(annual_mass_rate, axis = 0)
            diff = pred_precip - annual_precip
            diff = np.where(diff &lt; 0, 0, diff)
            # Return the (negative) normalized RMSD; it&#39;s negative because
            #   we are maximizing the objective function
            nrmsd = 100 * ((diff**2).mean() / annual_precip.sum())
            return -nrmsd

        assert pft in self.config[&#39;data&#39;][&#39;classes&#39;], f&#39;Invalid PFT: {pft}&#39;
        # Pass configuration parameters to MOD16StochasticSampler.run()
        for key in (&#39;chains&#39;, &#39;draws&#39;, &#39;tune&#39;, &#39;scaling&#39;):
            if key in self.config[&#39;optimization&#39;].keys():
                kwargs[key] = self.config[&#39;optimization&#39;][key]
        # Filter the parameters to just those for the PFT of interest
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
        params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
        # NOTE: This value was hard-coded in the extant version of MOD16
        if np.isnan(params_dict[&#39;beta&#39;]):
            params_dict[&#39;beta&#39;] = 250

        # There may be additional constraints when dynamic classes are used
        if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
            tower_obs, drivers, weights, constr = self._load_data_annual(pft)
        else:
            tower_obs, drivers, weights = self._load_data(pft)

        constraints = None
        if len(self.config[&#39;constraints&#39;]) &gt; 0:
            # Constraints may be defined in the config file but actually
            #   set to false; if none are set true, there are no constraints
            if any([
                self.config[&#39;constraints&#39;][k]
                for k in self.config[&#39;constraints&#39;].keys()
            ]):
                constraints = []
            if self.config[&#39;constraints&#39;][&#39;annual_precipitation&#39;]:
                # Get the mean daily temperature, to derive LHV
                air_t_day = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                    .index(&#39;temp_day&#39;)]
                air_t_night = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                    .index(&#39;temp_night&#39;)]
                air_t = np.stack(
                    [air_t_day, air_t_night], axis = 0).mean(axis = 0)
                lhv = latent_heat_vaporization(air_t)
                # Unpack sequence of years (e.g., 2000, 2001, ...), precip
                #   data (mm year-1)
                years, ann_precip = constr[&#39;annual_precipitation&#39;]
                # Add a version of constrain_by_map() function as a constraint
                constraints.append(partial(
                    constrain_by_map, years = years, lhv = lhv,
                    annual_precip = ann_precip))

        if k_folds &gt; 1:
            print(f&#39;NOTE: Using k-folds CV with k={k_folds}...&#39;)
            # Back-up the original (complete) datasets; we do this so we can
            #   simply mask out the test samples (1/k), after restoring the
            #   original datasets
            _drivers = [d.copy() for d in drivers]
            _tower_obs = tower_obs.copy()
            _weights = weights.copy()
            # Randomize the indices of the NPP data
            indices = np.arange(0, tower_obs.size)
            np.random.shuffle(indices)
            # Get the starting and ending index of each fold
            fold_idx = np.array([indices.size // k_folds] * k_folds) * np.arange(0, k_folds)
            fold_idx = list(map(list, zip(fold_idx, fold_idx + indices.size // k_folds)))
            # Ensure that the entire dataset is used; i.e., if each fold takes
            #   slices of the indices from A to B, ensure that the last fold&#39;s
            #   B is the final (maximum) index of the sequence
            fold_idx[-1][-1] = indices.max()
            idx_test = [indices[start:end] for start, end in fold_idx]

        # Loop over each fold (or the entire dataset, if num. folds == 1)
        for k, fold in enumerate(range(1, k_folds + 1)):
            backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
            if k_folds &gt; 1 and fold == 1:
                # Create an HDF5 file with the same name as the (original)
                #   netCDF4 back-end, store the test indices
                with h5py.File(backend.replace(&#39;nc4&#39;, &#39;h5&#39;), &#39;w&#39;) as hdf:
                    out = list(idx_test)
                    size = indices.size // k_folds
                    try:
                        out = np.stack(out)
                    except ValueError:
                        size = max((o.size for o in out))
                        for i in range(0, len(out)):
                            out[i] = np.concatenate((out[i], [np.nan] * (size - out[i].size)))
                    hdf.create_dataset(
                        &#39;test_indices&#39;, (k_folds, size), np.int32, np.stack(out))
                # Restore the original tower dataset
                if fold &gt; 1:
                    tower_obs = _tower_obs.copy()
                    weights = _weights.copy()
                # Set to NaN all the test indices
                idx = idx_test[k]
                tower_obs[idx] = np.nan
                # Same for drivers, after restoring from the original
                drivers = [
                    d.copy()[~np.isnan(tower_obs)] if d.ndim &gt; 0 else d.copy()
                    for d in _drivers
                ]
                weights = weights[~np.isnan(tower_obs)] # NOTE: Do first
                tower_obs = tower_obs[~np.isnan(tower_obs)]
            # Use a different naming scheme for the backend
            if k_folds &gt; 1:
                backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]

            print(&#39;Initializing sampler...&#39;)
            sampler = MOD16StochasticSampler(
                self.config, MOD16._et, params_dict, backend = backend,
                weights = weights, constraints = constraints)

            # Either: Enter diagnostic mode or run the sampler
            if plot_trace or ipdb:
                # This matplotlib setting prevents labels from overplotting
                pyplot.rcParams[&#39;figure.constrained_layout.use&#39;] = True
                trace = sampler.get_trace()
                if ipdb:
                    import ipdb
                    ipdb.set_trace()#FIXME
                az.plot_trace(trace, var_names = MOD16.required_parameters)
                pyplot.show()
                return

            # Clean the tower observations, run the sampler
            tower_obs = self.clean_observed(tower_obs, drivers)

            # Get (informative) priors for just those parameters that have them
            with open(self.config[&#39;optimization&#39;][&#39;prior&#39;], &#39;r&#39;) as file:
                prior = yaml.safe_load(file)
            prior_params = list(filter(
                lambda p: p in prior.keys(), sampler.required_parameters[&#39;ET&#39;]))
            prior = dict([
                (p, dict([(k, v[pft]) for k, v in prior[p].items()]))
                for p in prior_params
            ])

            # Determine whether any parameters are fixed
            fixed = []
            for name in MOD16.required_parameters:
                if self.config[&#39;optimization&#39;][&#39;fixed&#39;] is None:
                    break
                if name in self.config[&#39;optimization&#39;][&#39;fixed&#39;].keys():
                    fixed.append(
                        (name, self.config[&#39;optimization&#39;][&#39;fixed&#39;][name][pft]))
            fixed = dict(fixed)

            # Set var_names to tell ArviZ to plot only the free parameters; i.e.,
            #   those with priors and which are not fixed
            var_names = list(filter(
                lambda x: x in prior.keys(), MOD16.required_parameters))
            # Remove any random variables that have fixed values from the list
            #   of variables to be plotted
            for key in fixed.keys():
                if fixed[key] is not None:
                    var_names.remove(key)
            kwargs.update({&#39;var_names&#39;: var_names})

            sampler.run( # Only show the trace plot if not using k-folds
                tower_obs, drivers, prior = prior, fixed = fixed,
                save_fig = save_fig, show_fig = (k_folds == 1), **kwargs)


if __name__ == &#39;__main__&#39;:
    import fire
    import warnings
    with warnings.catch_warnings():
        warnings.simplefilter(&#39;ignore&#39;)
        fire.Fire(CalibrationAPI)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mod16.calibration.CalibrationAPI"><code class="flex name class">
<span>class <span class="ident">CalibrationAPI</span></span>
<span>(</span><span>config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class for calibrating the MOD16 ET model. Meant to be used
at the command line, in combination with the option to specify a
configuration file:</p>
<pre><code>--config=my_configuration.yaml
</code></pre>
<p>For example, to run calibration for PFT 1, you would write:</p>
<pre><code>python calibration.py tune --pft=1 --config=my_configuration.yaml
</code></pre>
<p>If <code>--config</code> is not provided, the default configuration file,
<code>mod16/MOD16_calibration_config.yaml</code> will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalibrationAPI(object):
    &#39;&#39;&#39;
    Convenience class for calibrating the MOD16 ET model. Meant to be used
    at the command line, in combination with the option to specify a
    configuration file:

        --config=my_configuration.yaml

    For example, to run calibration for PFT 1, you would write:

        python calibration.py tune --pft=1 --config=my_configuration.yaml

    If `--config` is not provided, the default configuration file,
    `mod16/MOD16_calibration_config.yaml` will be used.
    &#39;&#39;&#39;

    def __init__(self, config = None):
        config_file = config
        if config_file is None:
            config_file = os.path.join(
                MOD16_DIR, &#39;data/MOD16_calibration_config.yaml&#39;)
        print(f&#39;Using configuration file: &#34;{config_file}&#34;&#39;)
        with open(config_file, &#39;r&#39;) as file:
            self.config = yaml.safe_load(file)
        self.hdf5 = self.config[&#39;data&#39;][&#39;file&#39;]

    def _filter(self, raw: Sequence, size: int):
        &#39;Apply a smoothing filter with zero phase offset&#39;
        if size &gt; 1:
            window = np.ones(size) / size
            return np.apply_along_axis(
                lambda x: signal.filtfilt(window, np.ones(1), x), 0, raw)
        return raw # Or, revert to the raw data

    def _load_data(self, pft: int):
        &#39;Read in driver datasets from the HDF5 file&#39;
        with h5py.File(self.hdf5, &#39;r&#39;) as hdf:
            sites = hdf[&#39;FLUXNET/site_id&#39;][:].tolist()
            if hasattr(sites[0], &#39;decode&#39;):
                sites = [s.decode(&#39;utf-8&#39;) for s in sites]
            # Number of time steps
            nsteps = hdf[&#39;time&#39;].shape[0]
            # In case some tower sites should not be used
            blacklist = self.config[&#39;data&#39;][&#39;sites_blacklisted&#39;]
            # Get dominant PFT across a potentially heterogenous sub-grid,
            #   centered on the eddy covariance flux tower, UNLESS we have a
            #   dynamic land-cover map, in which case it is assumed
            #   (required) that there is only one PFT value per site
            pft_array = hdf[self.config[&#39;data&#39;][&#39;class_map&#39;]][:]
            if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
                pft_map = pft_array.copy()
                # Also, ensure the blacklist matches the shape of this mask;
                #   i.e., blacklisted sites should NEVER be used
                if blacklist is not None:
                    if len(blacklist) &gt; 0:
                        blacklist = np.array(blacklist)
                        blacklist = blacklist[None,:].repeat(pft_map.shape[0], axis = 0)
            else:
                # For a static PFT map, sub-site land-cover heterogeneity is
                #   allowed; get the dominant (single) PFT at each site
                pft_map = pft_dominant(pft_array, site_list = sites)
                # But do create a (T x N) selection mask
                pft_map = pft_map[np.newaxis,:].repeat(nsteps, axis = 0)

            # Get a binary mask that indicates which tower-days should be used
            #   to calibrate the current PFT class
            if blacklist is not None:
                pft_mask = np.logical_and(
                    pft_map == pft, ~np.in1d(sites, blacklist))
            else:
                pft_mask = pft_map == pft
            if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
                assert pft_mask.ndim == 2 and pft_mask.shape[0] == nsteps,\
                    &#39;Configuration setting &#34;classes_are_dynamic&#34; implies the &#34;class_map&#34; should be (T x N) but it is not&#39;

            # Get tower weights, for when towers are too close together
            weights = hdf[&#39;weights&#39;][:]
            # If only a single value is given for each site, repeat the weight
            #   along the time axis
            if weights.ndim == 1:
                weights = weights[None,:].repeat(nsteps, axis = 0)[pft_mask]

            # Read in tower observations
            tower_obs = hdf[&#39;FLUXNET/latent_heat&#39;][:][pft_mask]
            # Read the validation mask; mask out observations that are
            #   reserved for validation
            print(&#39;Masking out validation data...&#39;)
            mask = hdf[&#39;FLUXNET/validation_mask&#39;][pft]
            tower_obs[mask] = np.nan

            # Read in driver datasets0
            print(&#39;Loading driver datasets...&#39;)
            group = self.config[&#39;data&#39;][&#39;met_group&#39;]
            lw_net_day = hdf[f&#39;{group}/LWGNT_daytime&#39;][:][pft_mask]
            lw_net_night = hdf[f&#39;{group}/LWGNT_nighttime&#39;][:][pft_mask]
            sw_albedo = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;albedo&#39;]][:][pft_mask]
            sw_rad_day = hdf[f&#39;{group}/SWGDN_daytime&#39;][:][pft_mask]
            sw_rad_night = hdf[f&#39;{group}/SWGDN_nighttime&#39;][:][pft_mask]
            temp_day = hdf[f&#39;{group}/T10M_daytime&#39;][:][pft_mask]
            temp_night = hdf[f&#39;{group}/T10M_nighttime&#39;][:][pft_mask]
            tmin = hdf[f&#39;{group}/Tmin&#39;][:][pft_mask]

            # As long as the time series is balanced w.r.t. years (i.e., same
            #   number of records per year), the overall mean is the annual mean
            temp_annual = hdf[f&#39;{group}/T10M&#39;][:][pft_mask].mean(axis = 0)
            vpd_day = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_daytime&#39;][:][pft_mask],
                hdf[f&#39;{group}/PS_daytime&#39;][:][pft_mask],
                temp_day)
            vpd_night = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_nighttime&#39;][:][pft_mask],
                hdf[f&#39;{group}/PS_nighttime&#39;][:][pft_mask],
                temp_night)

            # After VPD is calculated, air pressure is based solely
            #   on elevation
            elevation = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;elevation&#39;]][:]
            elevation = elevation[np.newaxis,:]\
                .repeat(nsteps, axis = 0)[pft_mask]
            pressure = MOD16.air_pressure(elevation.mean(axis = -1))

            # Read in fPAR, LAI, and convert from (%) to [0,1]
            fpar = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;fPAR&#39;]][:][pft_mask]
            lai = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;LAI&#39;]][:][pft_mask]

            # If a heterogeneous sub-grid is used at each tower (i.e., there
            #   is a third axis to these datasets), then average over that
            #   sub-grid
            if sw_albedo.ndim == 2 and fpar.ndim == 2 and lai.ndim == 2:
                sw_albedo = np.nanmean(sw_albedo, axis = -1)
                fpar = np.nanmean(fpar, axis = -1)
                lai = np.nanmean(lai, axis = -1)
            # Convert fPAR from (%) to [0,1] and re-scale LAI; reshape fPAR and LAI
            fpar /= 100
            lai /= 10

        # Compile driver datasets
        drivers = [
            lw_net_day, lw_net_night, sw_rad_day, sw_rad_night, sw_albedo,
            temp_day, temp_night, temp_annual, tmin, vpd_day, vpd_night,
            pressure, fpar, lai
        ]
        return (tower_obs, drivers, weights)

    def _load_data_annual(self, pft: int):
        &#39;Read in driver datasets from the HDF5 file, structured by years&#39;
        constraints = dict()
        with h5py.File(self.hdf5, &#39;r&#39;) as hdf:
            sites = hdf[&#39;FLUXNET/site_id&#39;][:].tolist()
            if hasattr(sites[0], &#39;decode&#39;):
                sites = [s.decode(&#39;utf-8&#39;) for s in sites]
            # Number of time steps
            nsteps = hdf[&#39;time&#39;].shape[0]
            # In case some tower sites should not be used
            blacklist = self.config[&#39;data&#39;][&#39;sites_blacklisted&#39;]
            # Get dominant PFT across a potentially heterogenous sub-grid,
            #   centered on the eddy covariance flux tower
            pft_map = hdf[self.config[&#39;data&#39;][&#39;class_map&#39;]][:]
            # Also, ensure the blacklist matches the shape of this mask;
            #   i.e., blacklisted sites should NEVER be used
            if blacklist is not None:
                if len(blacklist) &gt; 0:
                    blacklist = np.array(blacklist)
                    blacklist = blacklist[None,:].repeat(pft_map.shape[0], axis = 0)

            years = np.array([
                datetime.date(*ymd).year for ymd in hdf[&#39;time&#39;][:].tolist()
            ])
            # If any days of this year correspond to the current PFT, select
            #   that year for calibration
            year_masks = []
            valid = self.config[&#39;data&#39;][&#39;classes&#39;] # Valid PFT classes
            for y in np.unique(years):
                # NOTE: This is where we select the current year
                pft_map_now = pft_map[years == y].swapaxes(0,1)
                pft_map_now = pft_map_now.reshape(
                    (pft_map_now.shape[0], pft_map_now.size // pft_map_now.shape[0]))
                # Update the PFT map (this year) to handle invalid PFT classes
                for i in range(pft_map_now.shape[0]):
                    if not np.in1d(pft_map_now[i], valid).all():
                        # Replace invalid PFTs (this year) with most common
                        #   valid PFT
                        potential = pft_map_now[i,np.in1d(pft_map_now[i], valid)]
                        if potential.size == 0:
                            continue # Skip this for now
                        pft_map_now[i,~np.in1d(pft_map_now[i], valid)] =\
                            mode(potential)
                # Now, with (mostly) good PFTs (this year), find the dominant
                pft_map_now = np.apply_along_axis(mode, 1, pft_map_now)
                year_masks.append(pft_map_now == pft)

            year_masks = np.stack(year_masks, axis = 0)
            # &#34;Average&#34; over the subgrid, then select years where a site has
            #   that PFT for any part of the year; to verify that this has
            #   resulted in an array that indicates which (full) years a PFT
            #   occurs at each site, try:
            # np.apply_along_axis(lambda x: x.sum(), 0, year_masks)
            pft_mask = year_masks[years - years.min()]
            # Set as False any tower-days where the tower is blacklisted
            if blacklist is not None:
                pft_mask[:,np.in1d(sites, blacklist)] = False
            # Finally, get an (N,) selection mask for the towers we want
            site_mask = pft_mask.any(axis = 0)

            # Get tower weights, for when towers are too close together
            weights = hdf[&#39;weights&#39;][:]
            # If only a single value is given for each site, repeat the weight
            #   along the time axis
            if weights.ndim == 1:
                weights = weights[None,...].repeat(nsteps, axis = 0)
            weights = weights[:,site_mask]

            # Read in tower observations; we select obs of interest in three
            #   steps because we want *only* matching tower-day observations
            #   but we&#39;ll want driver data for a full year if that year
            #   contains *any* matching tower-day observations
            print(&#39;Masking out validation data...&#39;)
            tower_obs = hdf[&#39;FLUXNET/latent_heat&#39;][:]
            tower_obs[~pft_mask] = np.nan # Step 1: Mask out invalid days
            # Step 2: Mask out validation samples
            tower_obs[hdf[&#39;FLUXNET/validation_mask&#39;][pft]] = np.nan
            tower_obs = tower_obs[:,site_mask] # Step 3: Select matching sites

            # Read in driver datasets0
            print(&#39;Loading driver datasets...&#39;)
            group = self.config[&#39;data&#39;][&#39;met_group&#39;]
            lw_net_day = hdf[f&#39;{group}/LWGNT_daytime&#39;][:][:,site_mask]
            lw_net_night = hdf[f&#39;{group}/LWGNT_nighttime&#39;][:][:,site_mask]
            sw_albedo = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;albedo&#39;]][:][:,site_mask]
            sw_rad_day = hdf[f&#39;{group}/SWGDN_daytime&#39;][:][:,site_mask]
            sw_rad_night = hdf[f&#39;{group}/SWGDN_nighttime&#39;][:][:,site_mask]
            temp_day = hdf[f&#39;{group}/T10M_daytime&#39;][:][:,site_mask]
            temp_night = hdf[f&#39;{group}/T10M_nighttime&#39;][:][:,site_mask]
            tmin = hdf[f&#39;{group}/Tmin&#39;][:][:,site_mask]

            if self.config[&#39;constraints&#39;][&#39;annual_precipitation&#39;]:
                # Convert mean annual precip (Y x N) to a (T x N) array,
                #   then subset
                ann_precip = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;annual_precip&#39;]][:]
                constraints[&#39;annual_precipitation&#39;] = (years, ann_precip[:,site_mask])

            # As long as the time series is balanced w.r.t. years (i.e., same
            #   number of records per year), the overall mean is the annual mean
            temp_annual = hdf[f&#39;{group}/T10M&#39;][:][:,site_mask].mean(axis = 0)
            vpd_day = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_daytime&#39;][:][:,site_mask],
                hdf[f&#39;{group}/PS_daytime&#39;][:][:,site_mask],
                temp_day)
            vpd_day = np.where(vpd_day &lt; 0, 0, vpd_day)
            vpd_night = MOD16.vpd(
                hdf[f&#39;{group}/QV10M_nighttime&#39;][:][:,site_mask],
                hdf[f&#39;{group}/PS_nighttime&#39;][:][:,site_mask],
                temp_night)
            vpd_night = np.where(vpd_night &lt; 0, 0, vpd_night)

            # After VPD is calculated, air pressure is based solely
            #   on elevation
            elevation = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;elevation&#39;]][:]
            elevation = elevation[np.newaxis,:]\
                .repeat(nsteps, axis = 0)[:,site_mask]
            pressure = MOD16.air_pressure(elevation.mean(axis = -1))

            # Read in fPAR, LAI, and convert from (%) to [0,1]
            fpar = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;fPAR&#39;]][:][:,site_mask]
            lai = hdf[self.config[&#39;data&#39;][&#39;datasets&#39;][&#39;LAI&#39;]][:][:,site_mask]

            # If a heterogeneous sub-grid is used at each tower (i.e., there
            #   is a third axis to these datasets), then average over that
            #   sub-grid
            if sw_albedo.ndim == 3 and fpar.ndim == 3 and lai.ndim == 3:
                sw_albedo = np.nanmean(sw_albedo, axis = -1)
                fpar = np.nanmean(fpar, axis = -1)
                lai = np.nanmean(lai, axis = -1)
            # Convert fPAR from (%) to [0,1] and re-scale LAI; reshape fPAR and LAI
            fpar /= 100
            lai /= 10

        drivers = [
            lw_net_day, lw_net_night, sw_rad_day, sw_rad_night, sw_albedo,
            temp_day, temp_night, temp_annual, tmin, vpd_day, vpd_night,
            pressure, fpar, lai
        ]
        return (tower_obs, drivers, weights, constraints)

    def clean_observed(
            self, raw: Sequence, drivers: Sequence, protocol: str = &#39;ET&#39;,
            filter_length: int = 2) -&gt; Sequence:
        &#39;&#39;&#39;
        Cleans observed tower flux data according to a prescribed protocol.
        NOT intended to be called from the command line.

        Parameters
        ----------
        raw : Sequence
        drivers : Sequence
        protocol : str
        filter_length : int
            The window size for the smoothing filter, applied to the observed
            data

        Returns
        -------
        Sequence
        &#39;&#39;&#39;
        # Read in the observed data and apply smoothing filter; then mask out
        #   negative latent heat observations
        obs = self._filter(raw, filter_length)
        return np.where(obs &lt; 0, np.nan, obs)

    def export_posterior(
            self, model: str, param: str, output_path: str, thin: int = 10,
            burn: int = 1000, k_folds: int = 1):
        &#39;&#39;&#39;
        Exports posterior distribution for a parameter, for each PFT to HDF5.

        Parameters
        ----------
        model : str
            The name of the model (only &#34;ET&#34; is supported)
        param : str
            The model parameter to export
        output_path : str
            The output HDF5 file path
        thin : int
            Thinning rate
        burn : int
            The burn-in (i.e., first N samples to discard)
        k_folds : int
            The number of k-folds used in cross-calibration/validation;
            if more than one (default), the folds for each PFT will be
            combined into a single HDF5 file
        &#39;&#39;&#39;
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][model])
        bplut = params_dict.copy()
        # Filter the parameters to just those for the PFT of interest
        post = []
        for pft in self.config[&#39;data&#39;][&#39;classes&#39;]:
            params = dict([(k, v[pft]) for k, v in params_dict.items()])
            post_by_fold = []
            for fold in range(1, k_folds + 1):
                backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] %\
                    (model, pft)
                if k_folds &gt; 1:
                    backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]
                # NOTE: This value was hard-coded in the extant version of MOD16
                if &#39;beta&#39; not in params:
                    params[&#39;beta&#39;] = 250
                sampler = MOD16StochasticSampler(
                    self.config, getattr(MOD16, &#39;_%s&#39; % model.lower()), params,
                    backend = backend)
                trace = sampler.get_trace()
                fit = trace.sel(draw = slice(burn, None, thin))[&#39;posterior&#39;]
                if param in fit:
                    post_by_fold.append(
                        az.extract_dataset(fit, combined = True)[param].values)
                else:
                    # In case there is, e.g., a parameter that takes on a
                    #   constant value for a specific PFT
                    if k_folds &gt; 1:
                        post_by_fold.append(
                            np.ones((1, post[-1].shape[-1])) * np.nan)
                    else:
                        a_key = list(fit.keys())[0]
                        post_by_fold.append(
                            np.ones(fit[a_key].values.shape) * np.nan)
            if k_folds &gt; 1:
                post.append(np.vstack(post_by_fold))
            else:
                post.extend(post_by_fold)
        # If not every PFT&#39;s posterior has the same number of samples (e.g.,
        #   when one set of chains was run longer than another)...
        if not all([p.shape == post[0].shape for p in post]):
            max_len = max([p.shape for p in post])[0]
            # ...Reshape all posteriors to match the greatest sample size
            post = [
                np.pad(
                    p.astype(np.float32), (0, max_len - p.size),
                    mode = &#39;constant&#39;, constant_values = (np.nan,))
                for p in post
            ]
        with h5py.File(output_path, &#39;a&#39;) as hdf:
            post = np.stack(post)
            ts = datetime.date.today().strftime(&#39;%Y-%m-%d&#39;) # Today&#39;s date
            dataset = hdf.create_dataset(
                f&#39;{param}_posterior&#39;, post.shape, np.float32, post)
            dataset.attrs[&#39;description&#39;] = &#39;CalibrationAPI.export_posterior() on {ts}&#39;

    def plot_autocorr(self, pft: int, k_folds: int = 1, **kwargs):
        &#39;&#39;&#39;
        Plot the autocorrelation in the trace for each parameter.

        Parameters
        ----------
        pft : int
            The numeric PFT code
        &#39;&#39;&#39;
        # Filter the parameters to just those for the PFT of interest
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
        params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
        backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
        # Use a different naming scheme for the backend
        if k_folds &gt; 1:
            for fold in range(1, k_folds + 1):
                sampler = MOD16StochasticSampler(
                    self.config, MOD16._et, params_dict,
                    backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):])
                sampler.plot_autocorr(**kwargs, title = f&#39;Fold {fold} of {k_folds}&#39;)
        else:
            sampler = MOD16StochasticSampler(
                self.config, MOD16._et, params_dict, backend = backend)
            sampler.plot_autocorr(**kwargs)

    def tune(
            self, pft: int, plot_trace: bool = False, k_folds: int = 1,
            ipdb: bool = False, save_fig: bool = False, **kwargs):
        &#39;&#39;&#39;
        Run the MOD16 ET calibration. If k-folds cross-validation is used,
        the model is calibrated on $k$ random subsets of the data and a
        series of file is created, e.g., as:

            MOD16_ET_calibration_PFT1.h5
            MOD16_ET_calibration_PFT1-k1.nc4
            MOD16_ET_calibration_PFT1-k2.nc4
            ...

        Where each `.nc4` file is a standard `arviz` backend and the `.h5`
        indicates which indices from the observations vector, after removing
        NaNs, were excluded (i.e., the indices of the test data).

        Parameters
        ----------
        pft : int
            The Plant Functional Type (PFT) to calibrate
        plot_trace : bool
            True to plot the trace for a previous calibration run; this will
            also NOT start a new calibration (Default: False)
        k_folds : int
            Number of folds to use in k-folds cross-validation; defaults to
            k=1, i.e., no cross-validation is performed.
        ipdb : bool
            True to drop the user into an ipdb prompt, prior to and instead of
            running calibration
        save_fig : bool
            True to save figures to files instead of showing them
            (Default: False)
        **kwargs
            Additional keyword arguments passed to
            `MOD16StochasticSampler.run()`

        NOTE that `MOD16StochasticSampler` inherits methods from the `mod17`
        module, including [run()](https://arthur-e.github.io/MOD17/calibration.html#mod17.calibration.StochasticSampler).
        &#39;&#39;&#39;
        def constrain_by_map(pred_le, years, lhv, annual_precip):
            # Constraint the results by (mean) annual precipitation
            # pred_le : np.ndarray - (T,N) array of predicted latent heat flux
            # years : np.ndarray - (T,) array indicating year, out of Y years
            # lhv : np.ndarray - (T,N) array of latent heat of vaporization
            # annual_precip : np.ndarray -
            #   (Y,N) array of the annual precipitation at the site
            mass_rate = (pred_le * 60 * 60 * 24) / lhv # Convert [W m-2] to [mm day-1]
            mass_rate[mass_rate &lt; 0] = 0
            annual_mass_rate = []
            for y in np.unique(years):
                a = np.apply_along_axis(
                    lambda x: x.sum(), 0, mass_rate[years == y])
                annual_mass_rate.append(a)
            pred_precip = np.stack(annual_mass_rate, axis = 0)
            diff = pred_precip - annual_precip
            diff = np.where(diff &lt; 0, 0, diff)
            # Return the (negative) normalized RMSD; it&#39;s negative because
            #   we are maximizing the objective function
            nrmsd = 100 * ((diff**2).mean() / annual_precip.sum())
            return -nrmsd

        assert pft in self.config[&#39;data&#39;][&#39;classes&#39;], f&#39;Invalid PFT: {pft}&#39;
        # Pass configuration parameters to MOD16StochasticSampler.run()
        for key in (&#39;chains&#39;, &#39;draws&#39;, &#39;tune&#39;, &#39;scaling&#39;):
            if key in self.config[&#39;optimization&#39;].keys():
                kwargs[key] = self.config[&#39;optimization&#39;][key]
        # Filter the parameters to just those for the PFT of interest
        params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
        params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
        # NOTE: This value was hard-coded in the extant version of MOD16
        if np.isnan(params_dict[&#39;beta&#39;]):
            params_dict[&#39;beta&#39;] = 250

        # There may be additional constraints when dynamic classes are used
        if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
            tower_obs, drivers, weights, constr = self._load_data_annual(pft)
        else:
            tower_obs, drivers, weights = self._load_data(pft)

        constraints = None
        if len(self.config[&#39;constraints&#39;]) &gt; 0:
            # Constraints may be defined in the config file but actually
            #   set to false; if none are set true, there are no constraints
            if any([
                self.config[&#39;constraints&#39;][k]
                for k in self.config[&#39;constraints&#39;].keys()
            ]):
                constraints = []
            if self.config[&#39;constraints&#39;][&#39;annual_precipitation&#39;]:
                # Get the mean daily temperature, to derive LHV
                air_t_day = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                    .index(&#39;temp_day&#39;)]
                air_t_night = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                    .index(&#39;temp_night&#39;)]
                air_t = np.stack(
                    [air_t_day, air_t_night], axis = 0).mean(axis = 0)
                lhv = latent_heat_vaporization(air_t)
                # Unpack sequence of years (e.g., 2000, 2001, ...), precip
                #   data (mm year-1)
                years, ann_precip = constr[&#39;annual_precipitation&#39;]
                # Add a version of constrain_by_map() function as a constraint
                constraints.append(partial(
                    constrain_by_map, years = years, lhv = lhv,
                    annual_precip = ann_precip))

        if k_folds &gt; 1:
            print(f&#39;NOTE: Using k-folds CV with k={k_folds}...&#39;)
            # Back-up the original (complete) datasets; we do this so we can
            #   simply mask out the test samples (1/k), after restoring the
            #   original datasets
            _drivers = [d.copy() for d in drivers]
            _tower_obs = tower_obs.copy()
            _weights = weights.copy()
            # Randomize the indices of the NPP data
            indices = np.arange(0, tower_obs.size)
            np.random.shuffle(indices)
            # Get the starting and ending index of each fold
            fold_idx = np.array([indices.size // k_folds] * k_folds) * np.arange(0, k_folds)
            fold_idx = list(map(list, zip(fold_idx, fold_idx + indices.size // k_folds)))
            # Ensure that the entire dataset is used; i.e., if each fold takes
            #   slices of the indices from A to B, ensure that the last fold&#39;s
            #   B is the final (maximum) index of the sequence
            fold_idx[-1][-1] = indices.max()
            idx_test = [indices[start:end] for start, end in fold_idx]

        # Loop over each fold (or the entire dataset, if num. folds == 1)
        for k, fold in enumerate(range(1, k_folds + 1)):
            backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
            if k_folds &gt; 1 and fold == 1:
                # Create an HDF5 file with the same name as the (original)
                #   netCDF4 back-end, store the test indices
                with h5py.File(backend.replace(&#39;nc4&#39;, &#39;h5&#39;), &#39;w&#39;) as hdf:
                    out = list(idx_test)
                    size = indices.size // k_folds
                    try:
                        out = np.stack(out)
                    except ValueError:
                        size = max((o.size for o in out))
                        for i in range(0, len(out)):
                            out[i] = np.concatenate((out[i], [np.nan] * (size - out[i].size)))
                    hdf.create_dataset(
                        &#39;test_indices&#39;, (k_folds, size), np.int32, np.stack(out))
                # Restore the original tower dataset
                if fold &gt; 1:
                    tower_obs = _tower_obs.copy()
                    weights = _weights.copy()
                # Set to NaN all the test indices
                idx = idx_test[k]
                tower_obs[idx] = np.nan
                # Same for drivers, after restoring from the original
                drivers = [
                    d.copy()[~np.isnan(tower_obs)] if d.ndim &gt; 0 else d.copy()
                    for d in _drivers
                ]
                weights = weights[~np.isnan(tower_obs)] # NOTE: Do first
                tower_obs = tower_obs[~np.isnan(tower_obs)]
            # Use a different naming scheme for the backend
            if k_folds &gt; 1:
                backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]

            print(&#39;Initializing sampler...&#39;)
            sampler = MOD16StochasticSampler(
                self.config, MOD16._et, params_dict, backend = backend,
                weights = weights, constraints = constraints)

            # Either: Enter diagnostic mode or run the sampler
            if plot_trace or ipdb:
                # This matplotlib setting prevents labels from overplotting
                pyplot.rcParams[&#39;figure.constrained_layout.use&#39;] = True
                trace = sampler.get_trace()
                if ipdb:
                    import ipdb
                    ipdb.set_trace()#FIXME
                az.plot_trace(trace, var_names = MOD16.required_parameters)
                pyplot.show()
                return

            # Clean the tower observations, run the sampler
            tower_obs = self.clean_observed(tower_obs, drivers)

            # Get (informative) priors for just those parameters that have them
            with open(self.config[&#39;optimization&#39;][&#39;prior&#39;], &#39;r&#39;) as file:
                prior = yaml.safe_load(file)
            prior_params = list(filter(
                lambda p: p in prior.keys(), sampler.required_parameters[&#39;ET&#39;]))
            prior = dict([
                (p, dict([(k, v[pft]) for k, v in prior[p].items()]))
                for p in prior_params
            ])

            # Determine whether any parameters are fixed
            fixed = []
            for name in MOD16.required_parameters:
                if self.config[&#39;optimization&#39;][&#39;fixed&#39;] is None:
                    break
                if name in self.config[&#39;optimization&#39;][&#39;fixed&#39;].keys():
                    fixed.append(
                        (name, self.config[&#39;optimization&#39;][&#39;fixed&#39;][name][pft]))
            fixed = dict(fixed)

            # Set var_names to tell ArviZ to plot only the free parameters; i.e.,
            #   those with priors and which are not fixed
            var_names = list(filter(
                lambda x: x in prior.keys(), MOD16.required_parameters))
            # Remove any random variables that have fixed values from the list
            #   of variables to be plotted
            for key in fixed.keys():
                if fixed[key] is not None:
                    var_names.remove(key)
            kwargs.update({&#39;var_names&#39;: var_names})

            sampler.run( # Only show the trace plot if not using k-folds
                tower_obs, drivers, prior = prior, fixed = fixed,
                save_fig = save_fig, show_fig = (k_folds == 1), **kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mod16.calibration.CalibrationAPI.clean_observed"><code class="name flex">
<span>def <span class="ident">clean_observed</span></span>(<span>self, raw:Â Sequence, drivers:Â Sequence, protocol:Â strÂ =Â 'ET', filter_length:Â intÂ =Â 2) â€‘>Â Sequence</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans observed tower flux data according to a prescribed protocol.
NOT intended to be called from the command line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raw</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>protocol</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>filter_length</code></strong> :&ensp;<code>int</code></dt>
<dd>The window size for the smoothing filter, applied to the observed
data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Sequence</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_observed(
        self, raw: Sequence, drivers: Sequence, protocol: str = &#39;ET&#39;,
        filter_length: int = 2) -&gt; Sequence:
    &#39;&#39;&#39;
    Cleans observed tower flux data according to a prescribed protocol.
    NOT intended to be called from the command line.

    Parameters
    ----------
    raw : Sequence
    drivers : Sequence
    protocol : str
    filter_length : int
        The window size for the smoothing filter, applied to the observed
        data

    Returns
    -------
    Sequence
    &#39;&#39;&#39;
    # Read in the observed data and apply smoothing filter; then mask out
    #   negative latent heat observations
    obs = self._filter(raw, filter_length)
    return np.where(obs &lt; 0, np.nan, obs)</code></pre>
</details>
</dd>
<dt id="mod16.calibration.CalibrationAPI.export_posterior"><code class="name flex">
<span>def <span class="ident">export_posterior</span></span>(<span>self, model:Â str, param:Â str, output_path:Â str, thin:Â intÂ =Â 10, burn:Â intÂ =Â 1000, k_folds:Â intÂ =Â 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports posterior distribution for a parameter, for each PFT to HDF5.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the model (only "ET" is supported)</dd>
<dt><strong><code>param</code></strong> :&ensp;<code>str</code></dt>
<dd>The model parameter to export</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The output HDF5 file path</dd>
<dt><strong><code>thin</code></strong> :&ensp;<code>int</code></dt>
<dd>Thinning rate</dd>
<dt><strong><code>burn</code></strong> :&ensp;<code>int</code></dt>
<dd>The burn-in (i.e., first N samples to discard)</dd>
<dt><strong><code>k_folds</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of k-folds used in cross-calibration/validation;
if more than one (default), the folds for each PFT will be
combined into a single HDF5 file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_posterior(
        self, model: str, param: str, output_path: str, thin: int = 10,
        burn: int = 1000, k_folds: int = 1):
    &#39;&#39;&#39;
    Exports posterior distribution for a parameter, for each PFT to HDF5.

    Parameters
    ----------
    model : str
        The name of the model (only &#34;ET&#34; is supported)
    param : str
        The model parameter to export
    output_path : str
        The output HDF5 file path
    thin : int
        Thinning rate
    burn : int
        The burn-in (i.e., first N samples to discard)
    k_folds : int
        The number of k-folds used in cross-calibration/validation;
        if more than one (default), the folds for each PFT will be
        combined into a single HDF5 file
    &#39;&#39;&#39;
    params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][model])
    bplut = params_dict.copy()
    # Filter the parameters to just those for the PFT of interest
    post = []
    for pft in self.config[&#39;data&#39;][&#39;classes&#39;]:
        params = dict([(k, v[pft]) for k, v in params_dict.items()])
        post_by_fold = []
        for fold in range(1, k_folds + 1):
            backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] %\
                (model, pft)
            if k_folds &gt; 1:
                backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]
            # NOTE: This value was hard-coded in the extant version of MOD16
            if &#39;beta&#39; not in params:
                params[&#39;beta&#39;] = 250
            sampler = MOD16StochasticSampler(
                self.config, getattr(MOD16, &#39;_%s&#39; % model.lower()), params,
                backend = backend)
            trace = sampler.get_trace()
            fit = trace.sel(draw = slice(burn, None, thin))[&#39;posterior&#39;]
            if param in fit:
                post_by_fold.append(
                    az.extract_dataset(fit, combined = True)[param].values)
            else:
                # In case there is, e.g., a parameter that takes on a
                #   constant value for a specific PFT
                if k_folds &gt; 1:
                    post_by_fold.append(
                        np.ones((1, post[-1].shape[-1])) * np.nan)
                else:
                    a_key = list(fit.keys())[0]
                    post_by_fold.append(
                        np.ones(fit[a_key].values.shape) * np.nan)
        if k_folds &gt; 1:
            post.append(np.vstack(post_by_fold))
        else:
            post.extend(post_by_fold)
    # If not every PFT&#39;s posterior has the same number of samples (e.g.,
    #   when one set of chains was run longer than another)...
    if not all([p.shape == post[0].shape for p in post]):
        max_len = max([p.shape for p in post])[0]
        # ...Reshape all posteriors to match the greatest sample size
        post = [
            np.pad(
                p.astype(np.float32), (0, max_len - p.size),
                mode = &#39;constant&#39;, constant_values = (np.nan,))
            for p in post
        ]
    with h5py.File(output_path, &#39;a&#39;) as hdf:
        post = np.stack(post)
        ts = datetime.date.today().strftime(&#39;%Y-%m-%d&#39;) # Today&#39;s date
        dataset = hdf.create_dataset(
            f&#39;{param}_posterior&#39;, post.shape, np.float32, post)
        dataset.attrs[&#39;description&#39;] = &#39;CalibrationAPI.export_posterior() on {ts}&#39;</code></pre>
</details>
</dd>
<dt id="mod16.calibration.CalibrationAPI.plot_autocorr"><code class="name flex">
<span>def <span class="ident">plot_autocorr</span></span>(<span>self, pft:Â int, k_folds:Â intÂ =Â 1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the autocorrelation in the trace for each parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pft</code></strong> :&ensp;<code>int</code></dt>
<dd>The numeric PFT code</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_autocorr(self, pft: int, k_folds: int = 1, **kwargs):
    &#39;&#39;&#39;
    Plot the autocorrelation in the trace for each parameter.

    Parameters
    ----------
    pft : int
        The numeric PFT code
    &#39;&#39;&#39;
    # Filter the parameters to just those for the PFT of interest
    params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
    params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
    backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
    # Use a different naming scheme for the backend
    if k_folds &gt; 1:
        for fold in range(1, k_folds + 1):
            sampler = MOD16StochasticSampler(
                self.config, MOD16._et, params_dict,
                backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):])
            sampler.plot_autocorr(**kwargs, title = f&#39;Fold {fold} of {k_folds}&#39;)
    else:
        sampler = MOD16StochasticSampler(
            self.config, MOD16._et, params_dict, backend = backend)
        sampler.plot_autocorr(**kwargs)</code></pre>
</details>
</dd>
<dt id="mod16.calibration.CalibrationAPI.tune"><code class="name flex">
<span>def <span class="ident">tune</span></span>(<span>self, pft:Â int, plot_trace:Â boolÂ =Â False, k_folds:Â intÂ =Â 1, ipdb:Â boolÂ =Â False, save_fig:Â boolÂ =Â False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the MOD16 ET calibration. If k-folds cross-validation is used,
the model is calibrated on $k$ random subsets of the data and a
series of file is created, e.g., as:</p>
<pre><code>MOD16_ET_calibration_PFT1.h5
MOD16_ET_calibration_PFT1-k1.nc4
MOD16_ET_calibration_PFT1-k2.nc4
...
</code></pre>
<p>Where each <code>.nc4</code> file is a standard <code>arviz</code> backend and the <code>.h5</code>
indicates which indices from the observations vector, after removing
NaNs, were excluded (i.e., the indices of the test data).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pft</code></strong> :&ensp;<code>int</code></dt>
<dd>The Plant Functional Type (PFT) to calibrate</dd>
<dt><strong><code>plot_trace</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to plot the trace for a previous calibration run; this will
also NOT start a new calibration (Default: False)</dd>
<dt><strong><code>k_folds</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of folds to use in k-folds cross-validation; defaults to
k=1, i.e., no cross-validation is performed.</dd>
<dt><strong><code>ipdb</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to drop the user into an ipdb prompt, prior to and instead of
running calibration</dd>
<dt><strong><code>save_fig</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to save figures to files instead of showing them
(Default: False)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments passed to
<code>MOD16StochasticSampler.run()</code></dd>
</dl>
<p>NOTE that <code><a title="mod16.calibration.MOD16StochasticSampler" href="#mod16.calibration.MOD16StochasticSampler">MOD16StochasticSampler</a></code> inherits methods from the <code>mod17</code>
module, including <a href="https://arthur-e.github.io/MOD17/calibration.html#mod17.calibration.StochasticSampler">run()</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tune(
        self, pft: int, plot_trace: bool = False, k_folds: int = 1,
        ipdb: bool = False, save_fig: bool = False, **kwargs):
    &#39;&#39;&#39;
    Run the MOD16 ET calibration. If k-folds cross-validation is used,
    the model is calibrated on $k$ random subsets of the data and a
    series of file is created, e.g., as:

        MOD16_ET_calibration_PFT1.h5
        MOD16_ET_calibration_PFT1-k1.nc4
        MOD16_ET_calibration_PFT1-k2.nc4
        ...

    Where each `.nc4` file is a standard `arviz` backend and the `.h5`
    indicates which indices from the observations vector, after removing
    NaNs, were excluded (i.e., the indices of the test data).

    Parameters
    ----------
    pft : int
        The Plant Functional Type (PFT) to calibrate
    plot_trace : bool
        True to plot the trace for a previous calibration run; this will
        also NOT start a new calibration (Default: False)
    k_folds : int
        Number of folds to use in k-folds cross-validation; defaults to
        k=1, i.e., no cross-validation is performed.
    ipdb : bool
        True to drop the user into an ipdb prompt, prior to and instead of
        running calibration
    save_fig : bool
        True to save figures to files instead of showing them
        (Default: False)
    **kwargs
        Additional keyword arguments passed to
        `MOD16StochasticSampler.run()`

    NOTE that `MOD16StochasticSampler` inherits methods from the `mod17`
    module, including [run()](https://arthur-e.github.io/MOD17/calibration.html#mod17.calibration.StochasticSampler).
    &#39;&#39;&#39;
    def constrain_by_map(pred_le, years, lhv, annual_precip):
        # Constraint the results by (mean) annual precipitation
        # pred_le : np.ndarray - (T,N) array of predicted latent heat flux
        # years : np.ndarray - (T,) array indicating year, out of Y years
        # lhv : np.ndarray - (T,N) array of latent heat of vaporization
        # annual_precip : np.ndarray -
        #   (Y,N) array of the annual precipitation at the site
        mass_rate = (pred_le * 60 * 60 * 24) / lhv # Convert [W m-2] to [mm day-1]
        mass_rate[mass_rate &lt; 0] = 0
        annual_mass_rate = []
        for y in np.unique(years):
            a = np.apply_along_axis(
                lambda x: x.sum(), 0, mass_rate[years == y])
            annual_mass_rate.append(a)
        pred_precip = np.stack(annual_mass_rate, axis = 0)
        diff = pred_precip - annual_precip
        diff = np.where(diff &lt; 0, 0, diff)
        # Return the (negative) normalized RMSD; it&#39;s negative because
        #   we are maximizing the objective function
        nrmsd = 100 * ((diff**2).mean() / annual_precip.sum())
        return -nrmsd

    assert pft in self.config[&#39;data&#39;][&#39;classes&#39;], f&#39;Invalid PFT: {pft}&#39;
    # Pass configuration parameters to MOD16StochasticSampler.run()
    for key in (&#39;chains&#39;, &#39;draws&#39;, &#39;tune&#39;, &#39;scaling&#39;):
        if key in self.config[&#39;optimization&#39;].keys():
            kwargs[key] = self.config[&#39;optimization&#39;][key]
    # Filter the parameters to just those for the PFT of interest
    params_dict = restore_bplut(self.config[&#39;BPLUT&#39;][&#39;ET&#39;])
    params_dict = dict([(k, v[pft]) for k, v in params_dict.items()])
    # NOTE: This value was hard-coded in the extant version of MOD16
    if np.isnan(params_dict[&#39;beta&#39;]):
        params_dict[&#39;beta&#39;] = 250

    # There may be additional constraints when dynamic classes are used
    if self.config[&#39;data&#39;][&#39;classes_are_dynamic&#39;]:
        tower_obs, drivers, weights, constr = self._load_data_annual(pft)
    else:
        tower_obs, drivers, weights = self._load_data(pft)

    constraints = None
    if len(self.config[&#39;constraints&#39;]) &gt; 0:
        # Constraints may be defined in the config file but actually
        #   set to false; if none are set true, there are no constraints
        if any([
            self.config[&#39;constraints&#39;][k]
            for k in self.config[&#39;constraints&#39;].keys()
        ]):
            constraints = []
        if self.config[&#39;constraints&#39;][&#39;annual_precipitation&#39;]:
            # Get the mean daily temperature, to derive LHV
            air_t_day = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                .index(&#39;temp_day&#39;)]
            air_t_night = drivers[MOD16StochasticSampler.required_drivers[&#39;ET&#39;]\
                .index(&#39;temp_night&#39;)]
            air_t = np.stack(
                [air_t_day, air_t_night], axis = 0).mean(axis = 0)
            lhv = latent_heat_vaporization(air_t)
            # Unpack sequence of years (e.g., 2000, 2001, ...), precip
            #   data (mm year-1)
            years, ann_precip = constr[&#39;annual_precipitation&#39;]
            # Add a version of constrain_by_map() function as a constraint
            constraints.append(partial(
                constrain_by_map, years = years, lhv = lhv,
                annual_precip = ann_precip))

    if k_folds &gt; 1:
        print(f&#39;NOTE: Using k-folds CV with k={k_folds}...&#39;)
        # Back-up the original (complete) datasets; we do this so we can
        #   simply mask out the test samples (1/k), after restoring the
        #   original datasets
        _drivers = [d.copy() for d in drivers]
        _tower_obs = tower_obs.copy()
        _weights = weights.copy()
        # Randomize the indices of the NPP data
        indices = np.arange(0, tower_obs.size)
        np.random.shuffle(indices)
        # Get the starting and ending index of each fold
        fold_idx = np.array([indices.size // k_folds] * k_folds) * np.arange(0, k_folds)
        fold_idx = list(map(list, zip(fold_idx, fold_idx + indices.size // k_folds)))
        # Ensure that the entire dataset is used; i.e., if each fold takes
        #   slices of the indices from A to B, ensure that the last fold&#39;s
        #   B is the final (maximum) index of the sequence
        fold_idx[-1][-1] = indices.max()
        idx_test = [indices[start:end] for start, end in fold_idx]

    # Loop over each fold (or the entire dataset, if num. folds == 1)
    for k, fold in enumerate(range(1, k_folds + 1)):
        backend = self.config[&#39;optimization&#39;][&#39;backend_template&#39;] % (&#39;ET&#39;, pft)
        if k_folds &gt; 1 and fold == 1:
            # Create an HDF5 file with the same name as the (original)
            #   netCDF4 back-end, store the test indices
            with h5py.File(backend.replace(&#39;nc4&#39;, &#39;h5&#39;), &#39;w&#39;) as hdf:
                out = list(idx_test)
                size = indices.size // k_folds
                try:
                    out = np.stack(out)
                except ValueError:
                    size = max((o.size for o in out))
                    for i in range(0, len(out)):
                        out[i] = np.concatenate((out[i], [np.nan] * (size - out[i].size)))
                hdf.create_dataset(
                    &#39;test_indices&#39;, (k_folds, size), np.int32, np.stack(out))
            # Restore the original tower dataset
            if fold &gt; 1:
                tower_obs = _tower_obs.copy()
                weights = _weights.copy()
            # Set to NaN all the test indices
            idx = idx_test[k]
            tower_obs[idx] = np.nan
            # Same for drivers, after restoring from the original
            drivers = [
                d.copy()[~np.isnan(tower_obs)] if d.ndim &gt; 0 else d.copy()
                for d in _drivers
            ]
            weights = weights[~np.isnan(tower_obs)] # NOTE: Do first
            tower_obs = tower_obs[~np.isnan(tower_obs)]
        # Use a different naming scheme for the backend
        if k_folds &gt; 1:
            backend = backend[:backend.rfind(&#39;.&#39;)] + f&#39;-k{fold}&#39; + backend[backend.rfind(&#39;.&#39;):]

        print(&#39;Initializing sampler...&#39;)
        sampler = MOD16StochasticSampler(
            self.config, MOD16._et, params_dict, backend = backend,
            weights = weights, constraints = constraints)

        # Either: Enter diagnostic mode or run the sampler
        if plot_trace or ipdb:
            # This matplotlib setting prevents labels from overplotting
            pyplot.rcParams[&#39;figure.constrained_layout.use&#39;] = True
            trace = sampler.get_trace()
            if ipdb:
                import ipdb
                ipdb.set_trace()#FIXME
            az.plot_trace(trace, var_names = MOD16.required_parameters)
            pyplot.show()
            return

        # Clean the tower observations, run the sampler
        tower_obs = self.clean_observed(tower_obs, drivers)

        # Get (informative) priors for just those parameters that have them
        with open(self.config[&#39;optimization&#39;][&#39;prior&#39;], &#39;r&#39;) as file:
            prior = yaml.safe_load(file)
        prior_params = list(filter(
            lambda p: p in prior.keys(), sampler.required_parameters[&#39;ET&#39;]))
        prior = dict([
            (p, dict([(k, v[pft]) for k, v in prior[p].items()]))
            for p in prior_params
        ])

        # Determine whether any parameters are fixed
        fixed = []
        for name in MOD16.required_parameters:
            if self.config[&#39;optimization&#39;][&#39;fixed&#39;] is None:
                break
            if name in self.config[&#39;optimization&#39;][&#39;fixed&#39;].keys():
                fixed.append(
                    (name, self.config[&#39;optimization&#39;][&#39;fixed&#39;][name][pft]))
        fixed = dict(fixed)

        # Set var_names to tell ArviZ to plot only the free parameters; i.e.,
        #   those with priors and which are not fixed
        var_names = list(filter(
            lambda x: x in prior.keys(), MOD16.required_parameters))
        # Remove any random variables that have fixed values from the list
        #   of variables to be plotted
        for key in fixed.keys():
            if fixed[key] is not None:
                var_names.remove(key)
        kwargs.update({&#39;var_names&#39;: var_names})

        sampler.run( # Only show the trace plot if not using k-folds
            tower_obs, drivers, prior = prior, fixed = fixed,
            save_fig = save_fig, show_fig = (k_folds == 1), **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mod16.calibration.MOD16StochasticSampler"><code class="flex name class">
<span>class <span class="ident">MOD16StochasticSampler</span></span>
<span>(</span><span>config:Â dict, model:Â Callable, params_dict:Â dictÂ =Â None, backend:Â strÂ =Â None, weights:Â SequenceÂ =Â None, model_name:Â strÂ =Â None, constraints:Â SequenceÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Markov Chain-Monte Carlo (MCMC) sampler for MOD16. The specific sampler
used is the Differential Evolution (DE) MCMC algorithm described by
Ter Braak (2008), though the implementation is specific to the PyMC3
library.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The function to call (with driver data and parameters); this function
should take driver data as positional arguments and the model
parameters as a <code>*Sequence</code>; it should require no external state.</dd>
<dt><strong><code>observed</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Sequence of observed values that will be used to calibrate the model;
i.e., model is scored by how close its predicted values are to the
observed values</dd>
<dt><strong><code>params_dict</code></strong> :&ensp;<code>dict</code> or <code>None</code></dt>
<dd>Dictionary of model parameters, to be used as initial values and as
the basis for constructing a new dictionary of optimized parameters</dd>
<dt><strong><code>backend</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Path to a NetCDF4 file backend (Default: None)</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>Sequence</code> or <code>None</code></dt>
<dd>Optional sequence of weights applied to the model residuals (as in
weighted least squares)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MOD16StochasticSampler(StochasticSampler):
    &#39;&#39;&#39;
    A Markov Chain-Monte Carlo (MCMC) sampler for MOD16. The specific sampler
    used is the Differential Evolution (DE) MCMC algorithm described by
    Ter Braak (2008), though the implementation is specific to the PyMC3
    library.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    model : Callable
        The function to call (with driver data and parameters); this function
        should take driver data as positional arguments and the model
        parameters as a `*Sequence`; it should require no external state.
    observed : Sequence
        Sequence of observed values that will be used to calibrate the model;
        i.e., model is scored by how close its predicted values are to the
        observed values
    params_dict : dict or None
        Dictionary of model parameters, to be used as initial values and as
        the basis for constructing a new dictionary of optimized parameters
    backend : str or None
        Path to a NetCDF4 file backend (Default: None)
    weights : Sequence or None
        Optional sequence of weights applied to the model residuals (as in
        weighted least squares)
    &#39;&#39;&#39;
    required_parameters = {
        &#39;ET&#39;: MOD16.required_parameters
    }
    required_drivers = {
        &#39;ET&#39;: [
            &#39;lw_net_day&#39;, &#39;lw_net_night&#39;, &#39;sw_rad_day&#39;, &#39;sw_rad_night&#39;,
            &#39;sw_albedo&#39;, &#39;temp_day&#39;, &#39;temp_night&#39;, &#39;temp_annual&#39;, &#39;tmin&#39;,
            &#39;vpd_day&#39;, &#39;vpd_night&#39;, &#39;pressure&#39;, &#39;fpar&#39;, &#39;lai&#39;
        ]
    }

    def compile_et_model(
            self, observed: Sequence, drivers: Sequence) -&gt; pm.Model:
        &#39;&#39;&#39;
        Creates a new ET model based on the prior distribution. Model can be
        re-compiled multiple times, e.g., for cross validation.

        There are two attributes that are set on the sampler when it is
        initialized that could be helpful here:

            self.priors
            self.bounds

        `self.priors` is a dict with a key for each parameter that has
        informative priors. For parameters with a non-informative (Uniform)
        prior, `self.bounds` is a similar dict (with a key for each parameter)
        that describes the lower and upper bounds of the Uniform prior, but
        this is deprecated.

        Parameters
        ----------
        observed : Sequence
            Sequence of observed values that will be used to calibrate the model;
            i.e., model is scored by how close its predicted values are to the
            observed values
        drivers : list or tuple
            Sequence of driver datasets to be supplied, in order, to the
            model&#39;s run function

        Returns
        -------
        pm.Model
        &#39;&#39;&#39;
        # Define the objective/ likelihood function
        log_likelihood = BlackBoxLikelihood(
            self.model, observed, x = drivers, weights = self.weights,
            objective = self.config[&#39;optimization&#39;][&#39;objective&#39;],
            constraints = self.constraints)
        # With this context manager, &#34;all PyMC3 objects introduced in the indented
        #   code block...are added to the model behind the scenes.&#34;
        with pm.Model() as model:
            # NOTE: Parameters shared with MOD17 are fixed based on MOD17
            #   re-calibration
            tmin_close = self.params[&#39;tmin_close&#39;]
            tmin_open = self.params[&#39;tmin_open&#39;]
            vpd_open = self.params[&#39;vpd_open&#39;]
            vpd_close = self.params[&#39;vpd_close&#39;]
            gl_sh =       pm.LogNormal(&#39;gl_sh&#39;, **self.prior[&#39;gl_sh&#39;])
            gl_wv =       pm.LogNormal(&#39;gl_wv&#39;, **self.prior[&#39;gl_wv&#39;])
            g_cuticular = pm.LogNormal(
                &#39;g_cuticular&#39;, **self.prior[&#39;g_cuticular&#39;])
            csl =         pm.LogNormal(&#39;csl&#39;, **self.prior[&#39;csl&#39;])
            rbl_min =     pm.Uniform(&#39;rbl_min&#39;, **self.prior[&#39;rbl_min&#39;])
            rbl_max =     pm.Uniform(&#39;rbl_max&#39;, **self.prior[&#39;rbl_max&#39;])
            beta =        pm.Uniform(&#39;beta&#39;, **self.prior[&#39;beta&#39;])
            # (Stochstic) Priors for unknown model parameters
            params_list = [
                tmin_close, tmin_open, vpd_open, vpd_close, gl_sh, gl_wv,
                g_cuticular, csl, rbl_min, rbl_max, beta
            ]
            # Convert model parameters to a tensor vector
            params = pt.as_tensor_variable(params_list)
            # Key step: Define the log-likelihood as an added potential
            pm.Potential(&#39;likelihood&#39;, log_likelihood(params))
        # If the value for this parameter (and this PFT) is fixed...
        fixed = dict()
        for i, name in enumerate(self.required_parameters[&#39;ET&#39;]):
            if self.fixed is not None:
                if name in self.fixed.keys():
                    if self.fixed[name] is not None:
                        # e.g., {beta: fixed_value}
                        fixed[getattr(model, name)] = self.fixed[name]
        if len(fixed) &gt; 0:
            # i.e., Return &#34;a distinct PyMC model with the relevant variables
            #   replaced by the intervention expressions; all remaining
            #   variables are cloned&#34;
            return pm.do(model, fixed)
        return model</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mod17.calibration.StochasticSampler</li>
<li>mod17.calibration.AbstractSampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mod16.calibration.MOD16StochasticSampler.required_drivers"><code class="name">var <span class="ident">required_drivers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mod16.calibration.MOD16StochasticSampler.required_parameters"><code class="name">var <span class="ident">required_parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mod16.calibration.MOD16StochasticSampler.compile_et_model"><code class="name flex">
<span>def <span class="ident">compile_et_model</span></span>(<span>self, observed:Â Sequence, drivers:Â Sequence) â€‘>Â pymc.model.core.Model</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new ET model based on the prior distribution. Model can be
re-compiled multiple times, e.g., for cross validation.</p>
<p>There are two attributes that are set on the sampler when it is
initialized that could be helpful here:</p>
<pre><code>self.priors
self.bounds
</code></pre>
<p><code>self.priors</code> is a dict with a key for each parameter that has
informative priors. For parameters with a non-informative (Uniform)
prior, <code>self.bounds</code> is a similar dict (with a key for each parameter)
that describes the lower and upper bounds of the Uniform prior, but
this is deprecated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>observed</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Sequence of observed values that will be used to calibrate the model;
i.e., model is scored by how close its predicted values are to the
observed values</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Sequence of driver datasets to be supplied, in order, to the
model's run function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pm.Model</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_et_model(
        self, observed: Sequence, drivers: Sequence) -&gt; pm.Model:
    &#39;&#39;&#39;
    Creates a new ET model based on the prior distribution. Model can be
    re-compiled multiple times, e.g., for cross validation.

    There are two attributes that are set on the sampler when it is
    initialized that could be helpful here:

        self.priors
        self.bounds

    `self.priors` is a dict with a key for each parameter that has
    informative priors. For parameters with a non-informative (Uniform)
    prior, `self.bounds` is a similar dict (with a key for each parameter)
    that describes the lower and upper bounds of the Uniform prior, but
    this is deprecated.

    Parameters
    ----------
    observed : Sequence
        Sequence of observed values that will be used to calibrate the model;
        i.e., model is scored by how close its predicted values are to the
        observed values
    drivers : list or tuple
        Sequence of driver datasets to be supplied, in order, to the
        model&#39;s run function

    Returns
    -------
    pm.Model
    &#39;&#39;&#39;
    # Define the objective/ likelihood function
    log_likelihood = BlackBoxLikelihood(
        self.model, observed, x = drivers, weights = self.weights,
        objective = self.config[&#39;optimization&#39;][&#39;objective&#39;],
        constraints = self.constraints)
    # With this context manager, &#34;all PyMC3 objects introduced in the indented
    #   code block...are added to the model behind the scenes.&#34;
    with pm.Model() as model:
        # NOTE: Parameters shared with MOD17 are fixed based on MOD17
        #   re-calibration
        tmin_close = self.params[&#39;tmin_close&#39;]
        tmin_open = self.params[&#39;tmin_open&#39;]
        vpd_open = self.params[&#39;vpd_open&#39;]
        vpd_close = self.params[&#39;vpd_close&#39;]
        gl_sh =       pm.LogNormal(&#39;gl_sh&#39;, **self.prior[&#39;gl_sh&#39;])
        gl_wv =       pm.LogNormal(&#39;gl_wv&#39;, **self.prior[&#39;gl_wv&#39;])
        g_cuticular = pm.LogNormal(
            &#39;g_cuticular&#39;, **self.prior[&#39;g_cuticular&#39;])
        csl =         pm.LogNormal(&#39;csl&#39;, **self.prior[&#39;csl&#39;])
        rbl_min =     pm.Uniform(&#39;rbl_min&#39;, **self.prior[&#39;rbl_min&#39;])
        rbl_max =     pm.Uniform(&#39;rbl_max&#39;, **self.prior[&#39;rbl_max&#39;])
        beta =        pm.Uniform(&#39;beta&#39;, **self.prior[&#39;beta&#39;])
        # (Stochstic) Priors for unknown model parameters
        params_list = [
            tmin_close, tmin_open, vpd_open, vpd_close, gl_sh, gl_wv,
            g_cuticular, csl, rbl_min, rbl_max, beta
        ]
        # Convert model parameters to a tensor vector
        params = pt.as_tensor_variable(params_list)
        # Key step: Define the log-likelihood as an added potential
        pm.Potential(&#39;likelihood&#39;, log_likelihood(params))
    # If the value for this parameter (and this PFT) is fixed...
    fixed = dict()
    for i, name in enumerate(self.required_parameters[&#39;ET&#39;]):
        if self.fixed is not None:
            if name in self.fixed.keys():
                if self.fixed[name] is not None:
                    # e.g., {beta: fixed_value}
                    fixed[getattr(model, name)] = self.fixed[name]
    if len(fixed) &gt; 0:
        # i.e., Return &#34;a distinct PyMC model with the relevant variables
        #   replaced by the intervention expressions; all remaining
        #   variables are cloned&#34;
        return pm.do(model, fixed)
    return model</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#head">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mod16" href="index.html">mod16</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mod16.calibration.CalibrationAPI" href="#mod16.calibration.CalibrationAPI">CalibrationAPI</a></code></h4>
<ul class="">
<li><code><a title="mod16.calibration.CalibrationAPI.clean_observed" href="#mod16.calibration.CalibrationAPI.clean_observed">clean_observed</a></code></li>
<li><code><a title="mod16.calibration.CalibrationAPI.export_posterior" href="#mod16.calibration.CalibrationAPI.export_posterior">export_posterior</a></code></li>
<li><code><a title="mod16.calibration.CalibrationAPI.plot_autocorr" href="#mod16.calibration.CalibrationAPI.plot_autocorr">plot_autocorr</a></code></li>
<li><code><a title="mod16.calibration.CalibrationAPI.tune" href="#mod16.calibration.CalibrationAPI.tune">tune</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mod16.calibration.MOD16StochasticSampler" href="#mod16.calibration.MOD16StochasticSampler">MOD16StochasticSampler</a></code></h4>
<ul class="">
<li><code><a title="mod16.calibration.MOD16StochasticSampler.compile_et_model" href="#mod16.calibration.MOD16StochasticSampler.compile_et_model">compile_et_model</a></code></li>
<li><code><a title="mod16.calibration.MOD16StochasticSampler.required_drivers" href="#mod16.calibration.MOD16StochasticSampler.required_drivers">required_drivers</a></code></li>
<li><code><a title="mod16.calibration.MOD16StochasticSampler.required_parameters" href="#mod16.calibration.MOD16StochasticSampler.required_parameters">required_parameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>